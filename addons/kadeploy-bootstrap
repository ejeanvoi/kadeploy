#!/usr/bin/ruby

require 'rubygems'
require 'net/ssh/gateway'
require 'net/ssh/multi'
require 'restclient'
require 'json'
require 'tempfile'
require 'ipaddr'


def g5k?
  `hostname --fqdn`.chomp =~ /grid5000.fr$/
end

USAGE           = "Usage: #{$0} [options] <deploykernels_directory>"

SSH_KEYS        = ["#{ENV['HOME']}/.ssh/id_dsa", "#{ENV['HOME']}/.ssh/id_rsa"]
HTTP_PROXY      = 'http://proxy:3128/'
if g5k?
  DEB_REPOSITORY = 'http://apt.grid5000.fr/kadeploy'
  G5K_ENVS = [
    'squeeze-x64-base',
    #'squeeze-x64-min',
    #'squeeze-x64-big'
  ]
  G5K_API       = 'https://api.grid5000.fr/2.0'
  G5K_POSTINSTALLS_PATH = '/grid5000/preinstalls/'
else
  DEB_REPOSITORY = ''
end

DOMAIN          = 'testbed.lan'
CLUSTER_NAME_SUFIX = '-cluster'
NODE_NAME_PREFIX = 'node-'

NET_ADMIN_IFACE= 'eth0'
USE_NET_DRIVER = false
USE_DISK_DRIVER = true

DEFAULT_CONSOLE_BAUD_RATE = '115200'
DEFAULT_CONSOLE_TTY_ID = '1'
DEFAULT_RAMDISK_SIZE = 800000

# Used when can't auto detect
DEFAULT_NET_DRIVER = 'e1000e'
DEFAULT_DISK_DRIVER = 'sata_nv'


# Kadeploy default config
CFG_KADEPLOY_USER = 'deploy'

CFG_KADEPLOY_MACROSTEP1 = { 
  :name => 'SetDeploymentEnv|SetDeploymentEnvUntrusted',
  :retries => 2,
  :timeout => 450
}
CFG_KADEPLOY_MACROSTEP2 = {
  :name => 'BroadcastEnv|BroadcastEnvKastafior',
  :retries => 1,
  :timeout => 900
}
CFG_KADEPLOY_MACROSTEP3 = [
  {
    :name => 'BootNewEnv|BootNewEnvClassical',
    :retries => 1,
    :timeout => 400
  },
  {
    :name => 'BootNewEnvHardReboot',
    :retries => 1,
    :timeout => 400
  }
]

CFG_KADEPLOY_PARTITION_SWAP_ID = 1
CFG_KADEPLOY_PARTITION_SWAP_SIZE = '4000M'
CFG_KADEPLOY_PARTITION_PROD_ID = 2
CFG_KADEPLOY_PARTITION_PROD_SIZE = '6000M'
CFG_KADEPLOY_PARTITION_DEPLOY_ID = 3
CFG_KADEPLOY_PARTITION_DEPLOY_SIZE = '6000M'
CFG_KADEPLOY_PARTITION_TMP_ID = 5
CFG_KADEPLOY_DISK_DEVICE = '/dev/sda'

CFG_KADEPLOY_PORT = 25300
CFG_KADEPLOY_VERBOSE = 3
CFG_KADEPLOY_CONF_PATH = '/etc/kadeploy3'
CFG_KADEPLOY_VAR_PATH = '/var/lib/kadeploy'
CFG_KADEPLOY_LOGFILE = '/var/log/kadeploy.log'
CFG_KADEPLOY_SSHKEY_PATH = File.join(CFG_KADEPLOY_CONF_PATH,'keys')
CFG_KADEPLOY_SSHKEY_DEFAULT = File.join(CFG_KADEPLOY_SSHKEY_PATH,'id_deploy')
CFG_KADEPLOY_HOSTNAMES_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'hostnames')
CFG_KADEPLOY_HOSTNAMES_SSHKEY = File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'.ssh_key')
CFG_KADEPLOY_ENVS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'envs')
CFG_KADEPLOY_ENVS_IMAGES_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'images')
CFG_KADEPLOY_ENVS_DESC_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'descriptions')
CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'install_scripts')
CFG_KADEPLOY_CACHE_PATH = '/var/cache/kadeploy/cache'
CFG_KADEPLOY_PREINSTALLS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'preinstalls')

def cfg_environment_desc(env)
  postinstall = ''
  if env[:postinstall]
    postinstall = "postinstall : #{File.join(CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH,File.basename(env[:postinstall][:file]))}|#{env[:postinstall][:filetype]}|#{env[:postinstall][:args]}\n"
  end

  "###\n"\
  "#{env[:desc]}\n"\
  "tarball : #{File.join(CFG_KADEPLOY_ENVS_IMAGES_PATH,File.basename(env[:tarball]))}|tgz\n"\
  + postinstall
end

CFG_KADEPLOY_CLIENT_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'client_conf')
def cfg_kadeploy_client()
  "default = kadeploy\n"\
  "kadeploy = #{$kanodes[:kadeploy][:fqdn]}:#{CFG_KADEPLOY_PORT}\n"
end


def cfg_kadeploy_macrostep(macrostep)
  ret = ''
  if macrostep.is_a?(Array)
    tmp = []
    macrostep.each do |step|
      tmp << cfg_kadeploy_macrostep(step)
      ret = tmp.join(',')
    end
  elsif macrostep.is_a?(Hash)
    ret = "#{macrostep[:name]}:#{macrostep[:retries]}:#{macrostep[:timeout]}"
  elsif macrostep.is_a?(String)
    ret = macrostep
  end
  ret
end

CFG_KADEPLOY_CONF_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'conf')
def cfg_kadeploy_conf()
  "verbose_level = #{CFG_KADEPLOY_VERBOSE}\n"\
  "tftp_repository = #{CFG_TFTP_PATH}\n"\
  "tftp_images_path = #{CFG_TFTP_KERNELS_DIR}\n"\
  "tftp_images_max_size = 600\n"\
  "tftp_cfg = #{CFG_TFTP_PXECONFIG_DIR}\n"\
  "db_kind = mysql\n"\
  "deploy_db_host = #{$kanodes[:sql][:fqdn]}\n"\
  "deploy_db_name = #{CFG_SQL_DB}\n"\
  "deploy_db_login = #{CFG_SQL_USER}\n"\
  "deploy_db_passwd = #{CFG_SQL_PASS_USER}\n"\
  "rights_kind = db\n"\
  "taktuk_connector = ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=publickey -o BatchMode=yes -i #{CFG_KADEPLOY_SSHKEY_DEFAULT}\n"\
  "taktuk_tree_arity = 0\n"\
  "taktuk_auto_propagate = false\n"\
  "tarball_dest_dir = /tmp\n"\
  "environment_extraction_dir = /mnt/dest\n"\
  "kadeploy_server = #{$kanodes[:kadeploy][:fqdn]}\n"\
  "kadeploy_server_port = #{CFG_KADEPLOY_PORT}\n"\
  "kadeploy_tcp_buffer_size = 8192\n"\
  "kadeploy_cache_dir = #{CFG_KADEPLOY_CACHE_PATH}\n"\
  "kadeploy_cache_size = 8000\n"\
  "ssh_port = 22\n"\
  "rsh_port = 514\n"\
  "test_deploy_env_port = #{CFG_KADEPLOY_PORT}\n"\
  "use_rsh_to_deploy = false\n"\
  "log_to_file = #{CFG_KADEPLOY_LOGFILE}\n"\
  "log_to_syslog = true\n"\
  "log_to_db = true\n"\
  "dbg_to_syslog = true\n"\
  "dbg_to_syslog_level = 3\n"\
  "reboot_window = 80\n"\
  "reboot_window_sleep_time = 10\n"\
  "nodes_check_window = 100\n"\
  "bootloader = chainload_pxe\n"\
  "purge_deployment_timer = 900\n"\
  "rambin_path = /rambin\n"\
  "mkfs_options = ext2@-b 4096 -O sparse_super,filetype,resize_inode,dir_index|ext3@-b 4096 -O sparse_super,filetype,resize_inode,dir_index\n"\
  "demolishing_env_threshold = 2\n"\
  "demolishing_env_auto_tag = false\n"\
  "bt_download_timeout = 1800\n"\
  "almighty_env_users = root,oar,deploy\n"\
  "max_preinstall_size = 10\n"\
  "max_postinstall_size = 10\n"\
  "vlan_hostname_suffix = -kavlan-VLAN_ID\n"
  #"async_end_of_deployment_hook = \n"\
  #"set_vlan_cmd = \n"
  # >>> TODO: add Bitorrent support in bootstrap
  #"bt_tracker_ip = \n"\
end

CFG_KADEPLOY_CMD_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'cmd')
def cfg_kadeploy_cmd()
  "\n"
end

CFG_KADEPLOY_CLUSTERS_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'clusters')
def cfg_kadeploy_clusters()
  cfg = ''
  $clusters.values.each do |cluster|
    cfg += "#{cluster[:name]}\n"
  end
  cfg
end

CFG_KADEPLOY_NODES_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'nodes')
def cfg_kadeploy_nodes()
  nodescfg = ''
  select_type($kanodes,:NODE).each do |node|
    nodescfg += "#{node[:fqdn]} #{node[:ipv4]} #{node[:cluster][:name]}\n"
  end
  nodescfg
end

CFG_KADEPLOY_PARTITION_CONF_FILE_PREFIX = File.join(CFG_KADEPLOY_CONF_PATH,'partition_file_')
def cfg_kadeploy_partition_file(cluster)
  # delete partitions
  "d\n1\nd\n2\nd\n3\nd\n4\n"\
  + # create swap partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_SWAP_ID}\n\n+#{CFG_KADEPLOY_PARTITION_SWAP_SIZE}\nt\n82\n"\
  + # create prod partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_PROD_ID}\n\n+#{CFG_KADEPLOY_PARTITION_PROD_SIZE}\nt\n#{CFG_KADEPLOY_PARTITION_PROD_ID}\n83\n"\
  + # create deploy partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\n\n+#{CFG_KADEPLOY_PARTITION_DEPLOY_SIZE}\nt\n#{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\nPARTTYPE\n"\
  + # create tmp partition
  "n\ne\n\n\nn\n\n\nt\n#{CFG_KADEPLOY_PARTITION_TMP_ID}\n83\n"\
  + # write changes
  "p\nw\n"\
  "\n"
end

def cfg_kadeploy_specific_conf_postinstall_path(cluster)
  postinstall = nil
  if cluster[:postinstall]
    postinstall = File.join(CFG_KADEPLOY_PREINSTALLS_PATH,"postinstall-#{cluster[:name]}.tgz")
  end
  postinstall 
end

def cfg_kadeploy_kapower_cmd(cmd)
  "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} #{ENV['USER']}@#{kavlan_gw()} \"kapower3 -m `cat #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'HOSTNAME_FQDN')}` #{cmd}\""
end

def cfg_kadeploy_kaconsole_cmd()
  "ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} #{ENV['USER']}@#{kavlan_gw()} \"kconsole3 -m `cat #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'HOSTNAME_FQDN')}`\""
end

CFG_KADEPLOY_SPECIFIC_CONF_FILE_PREFIX = File.join(CFG_KADEPLOY_CONF_PATH,'specific_conf_')
def cfg_kadeploy_specific_conf(cluster)
  postinstallpath = cfg_kadeploy_specific_conf_postinstall_path(cluster)
  "deploy_kernel = #{File.basename(cluster[:kernel][:vmlinuz])}\n"\
  + # >>> TODO: UPDATE
  "deploy_initrd = #{File.basename(cluster[:kernel][:initrd])} #{USE_NET_DRIVER ? "ETH_DRV=#{cluster[:drivers][:network]} " : ''}ETH_DEV=#{NET_ADMIN_IFACE} #{USE_DISK_DRIVER ? "DISK_DRV=#{cluster[:drivers][:disk]} " : ''}console=tty#{DEFAULT_CONSOLE_TTY_ID} console=ttyS#{DEFAULT_CONSOLE_TTY_ID},#{DEFAULT_CONSOLE_BAUD_RATE}n8 ramdisk_size=#{DEFAULT_RAMDISK_SIZE} rw noapic init=/linuxrc\n"\
  "block_device = #{CFG_KADEPLOY_DISK_DEVICE}\n"\
  "prod_part = #{CFG_KADEPLOY_PARTITION_PROD_ID}\n"\
  "deploy_part = #{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\n"\
  "tmp_part = #{CFG_KADEPLOY_PARTITION_TMP_ID}\n"\
  "swap_part = #{CFG_KADEPLOY_PARTITION_SWAP_ID}\n"\
  + # Kareboot
  "timeout_reboot_classical = 250\n"\
  "timeout_reboot_kexec = 100\n"\
  "cmd_soft_reboot = ssh -q -o BatchMode=yes -o StrictHostKeyChecking=no -o PreferredAuthentications=publickey -o ConnectTimeout=2 -o SetupTimeOut=5 -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_SSHKEY_DEFAULT} root@HOSTNAME_FQDN \"nohup /sbin/reboot -f >/dev/null &\"\n"\
  "cmd_hard_reboot = #{cfg_kadeploy_kapower_cmd('--off')}; #{cfg_kadeploy_kapower_cmd('--on')};\n"\
  + # Kapower
  "cmd_hard_power_on = #{cfg_kadeploy_kapower_cmd('--on')}\n"\
  "cmd_soft_power_off = ssh -q -o BatchMode=yes -o StrictHostKeyChecking=no -o PreferredAuthentications=publickey -o ConnectTimeout=2 -o SetupTimeOut=5 -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_SSHKEY_DEFAULT} root@HOSTNAME_FQDN \"nohup /sbin/halt &>/dev/null &\"\n"\
  "cmd_hard_power_off = #{cfg_kadeploy_kapower_cmd('--off')}\n"\
  "cmd_power_status = #{cfg_kadeploy_kapower_cmd('--status')}\n"\
  + # Kaconsole
  "cmd_console = #{cfg_kadeploy_kaconsole_cmd()}\n"\
  "kernel_params = console=tty#{DEFAULT_CONSOLE_TTY_ID} console=ttyS#{DEFAULT_CONSOLE_TTY_ID},#{DEFAULT_CONSOLE_BAUD_RATE}n8\n"\
  + # >>> TODO: UPDATE
  "partition_creation_kind = fdisk\n"\
  "pxe_header = #{CFG_PXE_HEADER.gsub("\n",'\n')}\n"\
  + #Automata description
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP1)}\n"\
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP2)}\n"\
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP3)}\n"\
  + (postinstallpath ? "admin_post_install = #{postinstallpath}|tgz|none\n" : '')
  #"nfsroot_kernel = \n"\
  #"nfsroot_params = \n"\
  #cmd_very_hard_power_off = /usr/sbin/pdumix -n HOSTNAME_FQDN -d
  #cmd_soft_power_on = /usr/sbin/pdumix -n HOSTNAME_FQDN -u
end

# frontend default config
CFG_FRONTEND_USER = 'testuser'
CFG_FRONTEND_USER_PASS = 'pass'
CFG_FRONTEND_SHELL = 'bash'
CFG_FRONTEND_PACKAGES = [
]


# TFTP default config
CFG_TFTP_PATH = '/var/lib/tftpboot'
CFG_TFTP_USER = CFG_KADEPLOY_USER
CFG_TFTP_CONF_FILE = '/etc/default/tftpd-hpa'
CFG_TFTP_PXECONFIG_DIR = 'pxelinux.cfg'
CFG_TFTP_KERNELS_DIR = 'kernels'

def cfg_tftp()
  "# /etc/default/tftpd-hpa\n"\
  "TFTP_USERNAME=\"#{CFG_TFTP_USER}\"\n"\
  "TFTP_DIRECTORY=\"#{CFG_TFTP_PATH}\"\n"\
  "TFTP_ADDRESS=\"0.0.0.0:69\"\n"\
  "TFTP_OPTIONS=\"-l -s -c\"\n"
end


# PXE default config
CFG_PXE_DISK='hd0'
CFG_PXE_PART=3
CFG_PXE_KERNEL='chain.c32'
CFG_PXE_BOOTFILES = [
  'chain.c32',
  'mboot.c32',
  'pxelinux.0',
]
CFG_PXE_CONFIG_PATH = File.join(CFG_TFTP_PATH,CFG_TFTP_PXECONFIG_DIR)
CFG_PXE_KERNELS_PATH = File.join(CFG_TFTP_PATH,CFG_TFTP_KERNELS_DIR)
CFG_PXE_HEADER = \
  "PROMPT 1\n"\
  "SERIAL 0 #{DEFAULT_CONSOLE_BAUD_RATE}\n"\
  "DEFAULT bootlabel\n"\
  "DISPLAY messages\n"\
  "TIMEOUT 50\n\n"\
  "label bootlabel\n"

def cfg_pxe(bootkernel=CFG_PXE_KERNEL,bootdisk=CFG_PXE_DISK,bootpart=CFG_PXE_PART)
  CFG_PXE_HEADER +
  "KERNEL #{bootkernel}\n"\
  "APPEND #{bootdisk} #{bootpart}\n"
end


# DNS default config
def cfg_dns_masknb()
  4 - (IPAddr.new($network[:mask]).to_i.to_s(2).count('1') / 8)
end

def cfg_dns_master_node(node)
  nodecfg = "#{node[:name]}      IN    A    #{node[:ipv4]}\n"
  nodecfg += "#{node[:name]}.#{node[:cluster][:name]}      IN    A    #{node[:ipv4]}\n" if node[:type] == :NODE
  nodecfg
end

def cfg_dns_reverse_node(node)
  ip = node[:ipv4].split('.')[-cfg_dns_masknb()..-1].reverse.join('.')
  "#{ip}    IN    PTR    #{node[:fqdn]}.\n"
end

def cfg_dns_base()
  "$TTL 3h\n"\
  "@    IN    SOA    #{$kanodes[:dns][:fqdn]}. postmaster.#{$kanodes[:dns][:fqdn]}. (\n"\
  "  #{Time.now.strftime("%Y%m%d%H%M%S")}\n"\
  "  4h\n"\
  "  1h\n"\
  "  4w\n"\
  "  1h\n"\
  ")\n"
end

def cfg_dns_master()
  nodescfg = ''
  $kanodes.each do |n,h|
    nodescfg += "#{cfg_dns_master_node(h)}\n"
  end

  "#{cfg_dns_base()}\n"\
  "@         IN    NS    #{$kanodes[:dns][:fqdn]}.\n"\
  "@         IN    A     #{$kanodes[:kadeploy][:ipv4]}\n"\
  + nodescfg
end

def cfg_dns_reverse()
  nodescfg = ''
  excls = []
  nodescfg += "#{cfg_dns_reverse_node($kanodes[:kadeploy])}\n"
  excls << $kanodes[:kadeploy][:ipv4]
  $kanodes.each do |n,h|
    unless excls.include?(h[:ipv4])
      nodescfg += "#{cfg_dns_reverse_node(h)}\n"
      excls << h[:ipv4]
    end
  end

  "#{cfg_dns_base()}\n"\
  "@         IN    NS    #{$kanodes[:dns][:fqdn]}.\n"\
  + nodescfg
end


# Bind9 default config
CFG_BIND_PATH='/etc/bind'
CFG_BIND_NAMED_FILE = File.join(CFG_BIND_PATH,'named.conf')
CFG_BIND_CONFIG_FILE_PREFIX = File.join(CFG_BIND_PATH,'db.')

def cfg_bind_reverse_domain()
 $network[:ipv4].to_s.split('.')[0..(4-cfg_dns_masknb()-1)].reverse.join('.')
end

def cfg_bind_reverse_file()
  "#{CFG_BIND_CONFIG_FILE_PREFIX}#{cfg_bind_reverse_domain()}"
end

def cfg_bind_master_file()
  "#{CFG_BIND_CONFIG_FILE_PREFIX}#{DOMAIN}"
end

def cfg_bind(dnsfwd)
  "zone \"#{DOMAIN}\" {\n"\
  "  type master;\n"\
  "  file \"#{cfg_bind_master_file()}\";\n"\
  "};\n\n"\
  "zone \"#{cfg_bind_reverse_domain()}.in-addr.arpa\" {\n"\
  "  type master;\n"\
  "  file \"#{cfg_bind_reverse_file()}\";\n"\
  "};\n"\
  "#{(dnsfwd.empty? ? '' : \
    "options {\n"\
    "  forwarders {\n"\
    "    #{dnsfwd};\n"\
    "  };\n"\
    "};\n"\
  )}"
end


# Resolv.conf default config
CFG_RESOLVCONF_FILE = '/etc/resolv.conf'

def cfg_resolvconf()
  "domain #{DOMAIN}\n"\
  "search #{DOMAIN}\n"\
  "nameserver #{$kanodes[:dns][:ipv4]}\n"
end


# DHCP default config
CFG_DHCP_CONF_FILE='/etc/dhcp/dhcpd.conf'
CFG_DHCP_PXE_MAGIC='F1:00:74:7E'
def cfg_dhcp_node(node)
  "  host #{node[:fqdn]} {\n"\
  "    hardware ethernet #{node[:mac]};\n"\
  "    fixed-address #{node[:ipv4]};\n"\
  "    option host-name \"#{node[:name]}\";\n"\
  "  }\n"
end

def cfg_dhcp()
  nodescfg = ''
  excls = []
  nodescfg += "#{cfg_dhcp_node($kanodes[:kadeploy])}\n"
  excls << $kanodes[:kadeploy][:ipv4]
  $kanodes.each do |n,h|
    unless excls.include?(h[:ipv4])
      nodescfg += "#{cfg_dhcp_node(h)}\n"
      excls << h[:ipv4]
    end
  end

  "default-lease-time 28800;\n"\
  "max-lease-time	86400;\n"\
  + # specific boot options
  "allow booting;\n"\
  "allow bootp;\n\n"\
  "not-authoritative;\n\n"\
  "use-host-decl-names on;\n\n"\
  "log-facility local7;\n\n"\
  + # PXE class options
  "option space PXE;\n"\
  "option PXE.mtftp-ip code 1 = ip-address;\n"\
  "option PXE.mtftp-cport code 2 = unsigned integer 16;\n"\
  "option PXE.mtftp-sport code 3 = unsigned integer 16;\n"\
  "option PXE.mtftp-tmout code 4 = unsigned integer 8;\n"\
  "option PXE.mtftp-delay code 5 = unsigned integer 8;\n"\
  "option PXE.discovery-control code 6 = unsigned integer 8;\n"\
  "option PXE.discovery-mcast-addr code 7 = ip-address;\n\n"\
  + # pxelinux options
  "option space pxelinux;\n"\
  "option pxelinux.magic code 208 = string;\n"\
  "option pxelinux.configfile code 209 = text;\n"\
  "option pxelinux.pathprefix code 210 = text;\n"\
  "option pxelinux.reboottime code 211 = unsigned integer 32;\n"\
  "site-option-space \"pxelinux\";\n"\
  "option pxelinux.magic #{CFG_DHCP_PXE_MAGIC};\n"\
  "option pxelinux.reboottime 30;\n\n"\
  + # PXE class
  "class \"PXE\" {\n"\
	"  match if substring(option vendor-class-identifier, 0, 9) = \"PXEClient\";\n"\
  "  filename \"pxelinux.0\";\n"\
  "  option vendor-class-identifier \"PXEClient\";\n"\
  "  vendor-option-space PXE;\n"\
	"  option PXE.mtftp-ip 0.0.0.0;\n"\
  "}\n\n"\
  + # Experiments network
  "subnet #{$network[:ipv4]} netmask #{$network[:mask]} {\n"\
  "  option subnet-mask #{$network[:mask]};\n"\
  "  option broadcast-address #{$network[:broadcast]};\n"\
  "  option routers #{$network[:gateway]};\n"\
  "  option domain-name \"#{DOMAIN}\";\n"\
  "  option domain-name-servers #{$kanodes[:dns][:ipv4]};\n"\
  + # Kadeploy server
  "  next-server #{$kanodes[:tftp][:ipv4]};\n\n"\
  + # Deploiement nodes
  ""\
  + nodescfg +
  "}\n"
end



# SQL default config
CFG_SQL_USER = CFG_KADEPLOY_USER
CFG_SQL_DB = 'deploy3'
CFG_SQL_PASS_ROOT = 'kadeploy'
CFG_SQL_PASS_USER = "#{CFG_KADEPLOY_USER}-pass"

def cfg_sql()
  # Cleaning up
  "DROP DATABASE IF EXISTS #{CFG_SQL_DB};\n"\
  + # Kadeploy database
  "CREATE DATABASE #{CFG_SQL_DB};\n"\
  + # Kadeploy user
  "GRANT ALL ON #{CFG_SQL_DB}.* TO '#{CFG_SQL_USER}'@'#{$kanodes[:kadeploy][:fqdn]}' IDENTIFIED BY '#{CFG_SQL_PASS_USER}';\n"\
  + # Kadeploy tables, table environments
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`environments` (\n"\
  "  `id` int(10) unsigned NOT NULL auto_increment,\n"\
  "  `name` varchar(255) NOT NULL default '',\n"\
  "  `version` int(10) unsigned NOT NULL default '0',\n"\
  "  `description` text,\n"\
  "  `author` varchar(56) NOT NULL default '',\n"\
  "  `tarball` varchar(512) NOT NULL,\n"\
  "  `preinstall` varchar(512) NOT NULL,\n"\
  "  `postinstall` varchar(512) NOT NULL,\n"\
  "  `hypervisor` varchar(255) NOT NULL,\n"\
  "  `hypervisor_params` varchar(255) NOT NULL,\n"\
  "  `initrd` varchar(255) NOT NULL,\n"\
  "  `kernel` varchar(255) NOT NULL,\n"\
  "  `kernel_params` varchar(255) NOT NULL,\n"\
  "  `fdisk_type` varchar(2) default NULL,\n"\
  "  `filesystem` varchar(9) default NULL,\n"\
  "  `user` varchar(255) default 'nobody',\n"\
  "  `allowed_users` varchar(512) NOT NULL,\n"\
  "  `environment_kind` varchar(10) NOT NULL,\n"\
  "  `visibility` varchar(8) NOT NULL,\n"\
  "  `demolishing_env` int(8) NOT NULL default '0',\n"\
  "  PRIMARY KEY  (`id`)\n"\
  ") ENGINE=MyISAM  DEFAULT CHARSET=utf8;\n"\
  + # table log
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`log` (\n"\
  "  `deploy_id` varchar(41) NOT NULL,\n"\
  "  `hostname` varchar(256) NOT NULL,\n"\
  "  `step1` varchar(45) NOT NULL,\n"\
  "  `step2` varchar(45) NOT NULL,\n"\
  "  `step3` varchar(45) NOT NULL,\n"\
  "  `timeout_step1` smallint(5) unsigned NOT NULL,\n"\
  "  `timeout_step2` smallint(5) unsigned NOT NULL,\n"\
  "  `timeout_step3` smallint(5) unsigned NOT NULL,\n"\
  "  `retry_step1` tinyint(1) unsigned NOT NULL,\n"\
  "  `retry_step2` tinyint(1) unsigned NOT NULL,\n"\
  "  `retry_step3` tinyint(1) unsigned NOT NULL,\n"\
  "  `start` int(10) unsigned NOT NULL,\n"\
  "  `step1_duration` int(10) unsigned NOT NULL,\n"\
  "  `step2_duration` int(10) unsigned NOT NULL,\n"\
  "  `step3_duration` int(10) unsigned NOT NULL,\n"\
  "  `env` varchar(64) NOT NULL,\n"\
  "  `anonymous_env` varchar(6) NOT NULL,\n"\
  "  `md5` varchar(35) NOT NULL,\n"\
  "  `success` varchar(6) NOT NULL,\n"\
  "  `error` varchar(255) NOT NULL,\n"\
  "  `user` varchar(16) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # table nodes
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`nodes` (\n"\
  "  `hostname` varchar(256) NOT NULL,\n"\
  "  `state` varchar(16) NOT NULL,\n"\
  "  `env_id` int(10) NOT NULL,\n"\
  "  `date` int(10) unsigned NOT NULL,\n"\
  "  `user` varchar(16) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # rights
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`rights` (\n"\
  "  `user` varchar(30) NOT NULL,\n"\
  "  `node` varchar(256) NOT NULL,\n"\
  "  `part` varchar(50) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # Kadeploy rights
  "INSERT INTO #{CFG_SQL_DB}.rights (user,node,part) VALUES('root','*','*');\n"\
  "FLUSH PRIVILEGES;\n"
end


# mySQL default config
CFG_MYSQL_CONF_FILE = '/etc/mysql/my.cnf'
CFG_MYSQL_VERSION = '5.1'
CFG_MYSQL_PORT = 3306

def cfg_mysql()
  "[client]\n"\
  "port = #{CFG_MYSQL_PORT}\n"\
  "\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "[mysqld_safe]\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "nice = 0\n"\
  "\n"\
  "[mysqld]\n"\
  "user = mysql\n"\
  "pid-file = /var/run/mysqld/mysqld.pid\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "port = #{CFG_MYSQL_PORT}\n"\
  "basedir = /usr\n"\
  "datadir = /var/lib/mysql\n"\
  "tmpdir = /tmp\n"\
  "language = /usr/share/mysql/english\n"\
  "skip-external-locking\n"\
  "query_cache_limit = 1M\n"\
  "query_cache_size = 16M\n"\
  "expire_logs_days = 10\n"\
  "max_binlog_size = 100M\n"\
  "\n"\
  "[mysqldump]\n"\
  "quick\n"\
  "quote-names\n"\
  "max_allowed_packet = 16M\n"\
  "\n"\
  "[mysql]\n"\
  "no-auto-rehash\n"\
  "\n"\
  "[isamchk]\n"\
  "key_buffer = 16M\n"
end




if g5k?
  $site = `hostname --fqdn`.chomp.split('.',2)[1]
else
  $site = ''
end
$allnodes=[]
$kanodes={}
$kaenvs={}
$clusters={}
$deplkernels = {}
$stunnels = {}
$hostscache = {}
$network = {}

options = {}
@options = options

MSG_ERROR=0
MSG_WARNING=1
MSG_INFO=2

def msg(str, type=nil, quit=false)
  case type
  when MSG_ERROR
    puts("### Error: #{str} ###")
  when MSG_WARNING
    puts("### Warning: #{str} ###")
  when MSG_INFO
    puts("[#{(Time.now - $startt).to_i}] #{str}")
  else
    puts str
  end
  exit 1 if quit
end

def gethostbysession(session)
  unless $hostscache[session]
    $hostscache[session] = sexec(session,'hostname',true,true,false,false)[0].chomp
  end
  $hostscache[session]
end

def sexec(session, cmd, critical = true, showerr = true, showout = false, checkhost = true)
  outs = []
  errs = []
  if checkhost
    host = gethostbysession(session)
  else
    host = session.host
  end
  
  chtmp = session.open_channel do |channel|
    channel.exec(cmd) do |ch, success|
      unless success
        msg("unable to execute '#{cmd}' on #{host}",MSG_ERROR)
      end
      msg("Executing '#{cmd}' on #{host}]",MSG_INFO) \
        if @options[:debug]
  
      channel.on_data do |ch,data|
        outs += data.strip.split("\n").collect!{|l| l.strip}
        msg("[#{host}] #{data.strip}") \
          if @options[:debug] or showout
      end
      
      channel.on_extended_data do |ch,type,data|
        errs += data.strip.split("\n").collect!{|l| l.strip}
      end
      
      channel.on_request("exit-status") do |ch, data|
        status = data.read_long
        if status != 0 and showerr
          msg("exec of '#{cmd}' on #{host} failed " \
            "with return status #{status.to_s}",MSG_ERROR)
          msg("---stdout dump---")
          outs.each { |out| msg(out) } unless outs.empty?
          msg("---stderr dump---")
          errs.each { |err| msg(err) } unless errs.empty?
          msg("---\n")
          exit 1 if critical
        end
      end

      #channel.wait
    end
  end
  
  chtmp.wait

  outs
end

def kavlan_gw()
  "kavlan-#{$kavlan_id}#{$site.empty? ? '' : ".#{$site}"}"
end

def kavlan_node(name)
  "#{name.split('.')[0]}-#{kavlan_gw()}"
end

SSH_TUNNEL_TIMEOUT=20
def ssh_tunnel_create(session,dstport,dsthost,srcport=nil,srchost=nil)
  srcport = dstport unless srcport
  srchost = gethostbysession(session) unless srchost

  unless $stunnels["#{srchost}:#{srcport}"]
    # Copying ssh private key on gateway
    scp(srchost,$sshkeyfile,'.ssh/')
    # Kill already existing process listening on srcport
    tmp = sexec(session,"lsof -i4 | grep LISTEN | grep localhost:#{srcport}",false,false)[0]
    if tmp and !tmp.empty?
      msg("A process is already listening on port #{srcport}, trying to kill it",MSG_WARNING)
      sexec(session,"kill #{tmp.chomp.split[1]}")
      time_start = Time.now
      begin
        tmp = sexec(session,"lsof -i4 | grep LISTEN | grep localhost:#{srcport}",false,false)[0]
        sexec(session,"kill -9 #{tmp.chomp.split[1]}") if (Time.now - time_start) > 2
        msg("Killing process that listen on #{srchost}:#{srcport} failed",MSG_ERROR,true) if Time.now - time_start > SSH_TUNNEL_TIMEOUT
        sleep(0.1)
      end until !tmp or tmp.empty?
    end

    $stunnels["#{srchost}:#{srcport}"] = {}
    $stunnels["#{srchost}:#{srcport}"][:dsthost] = dsthost
    $stunnels["#{srchost}:#{srcport}"][:dstport] = dstport
    #$stunnels["#{srchost}:#{srcport}"][:thread] = Thread.new do 

#gwsession = Net::SSH::Gateway.new(kavlan_gw(), ENV['USER'], :keys => $sshkeyfile)
#gwsession.ssh(kavlan_node($kaserver),'root') do |mysession|
      sexec(session,"ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -N -L #{srcport}:#{dsthost}:#{dstport} #{ENV['USER']}@#{kavlan_gw()} &>/dev/null &")
#end
#    end
#    $stunnels["#{srchost}:#{srcport}"][:thread].run
    time_start = Time.now
    begin
      tmp = sexec(session,"lsof -i4 | grep LISTEN | grep localhost:#{srcport}",false,false)[0]
      sleep(0.1)
      msg("SSH tunnel creation on #{srchost}:#{srcport} failed",MSG_ERROR,true) if Time.now - time_start > SSH_TUNNEL_TIMEOUT
    end while !tmp or tmp.empty?
    $stunnels["#{srchost}:#{srcport}"][:pid] = tmp.split[1]
  else
    if $stunnels["#{srchost}:#{srcport}"][:dsthost] != dsthost \
      or $stunnels["#{srchost}:#{srcport}"][:dstport] != dstport
      msg("Trying to create two tunnels on the same local port (#{srcport})",MSG_WARNING)
    end
  end
end
=begin
      chtmp = session.open_channel do |channel|
        channel.exec("ssh -o StrictHostKeyChecking=no -N -L #{srcport}:#{dsthost}:#{dstport} #{ENV['USER']}@#{kavlan_gw()}") do |ch,success|
        end
      end
      $stunnels["#{srchost}:#{srcport}"][:channel] = chtmp
      chtmp.wait
=end

def ssh_tunnel_destroy(session,srcport,srchost)
  if $stunnels["#{srchost}:#{srcport}"]
    # Removing ssh private key
    sexec(session,"rm -f #{File.join('.ssh',$sshkeyfile)}")
    if $stunnels["#{srchost}:#{srcport}"][:pid]
      tmp = sexec(session,"ps -p #{$stunnels["#{srchost}:#{srcport}"][:pid]}",false,false)
      if tmp and tmp[1] and !tmp[1].chomp.empty?
        sexec(session,"kill #{$stunnels["#{srchost}:#{srcport}"][:pid]}")
      end
    end
#    $stunnels["#{srchost}:#{srcport}"][:thread].kill
#    $stunnels["#{srchost}:#{srcport}"][:thread].join
    $stunnels.delete("#{srchost}:#{srcport}")
  end
end

=begin
def ssh_tunnels_destroy()
  $stunnels.values.each do |tunnel|
    #tunnel[:channel].close if tunnel[:channel]
    if tunnel[:thread]
      tunnel[:thread].kill
      tunnel[:thread].join
    end
  end
end
=end

def apt_cmd(session,shcmd,aptcmd,aptopts,params='')
  aptproxy = 'Acquire::http::Proxy=\"http://localhost:3128\"'
  optname = Proc.new { |v|
      if v.size > 1
        "--#{v}"
      else
        "-#{v}"
      end
  }

  if aptopts.is_a?(Hash)
    aptopts['o'] = [aptproxy]
    tmpopts = []
    aptopts.each do |k,v|

      if v.is_a?(String)
        tmpopts << "#{optname.call(k)} #{v}"
      elsif v.is_a?(Array)
        v.each { |o| tmpopts << "#{optname.call(k)} #{o}" }
      elsif v == nil
        tmpopts << k
      end
    end
    aptopts = tmpopts.join(' ')
  elsif aptopts.is_a?(Array)
    aptopts = aptopts.collect{|v| optname.call(v)}.join(' ')
    aptopts += " #{optname.call('o')} #{aptproxy}"
  end
  params = params.join(' ') if params.is_a?(Array)

  sexec(session,"#{shcmd} #{aptcmd} #{aptopts} #{params}")
end

def apt_update(session)
  apt_cmd(session,'apt-get','update',['q'])
end

def apt_install(session,packages)
  apt_cmd(session,'apt-get','install',['q','y','force-yes','allow-unauthenticated'],packages)
end

def apt_remove(session,packages)
  apt_cmd(session,'apt-get','remove',['q','y','force-yes','purge'],packages)
end

def get_open_port()
  tmp=`netstat -l -n`
  usedports=[]
  tmp.each do |line|
    if line =~ /^\w+\s+\d+\s+\d+\s+.+:([-_\.\w]+)\s+.+:.+\s+\w*$/
      usedports << Regexp.last_match(1) unless usedports.include?(Regexp.last_match(1))
    end
  end

  begin
    randport = rand(2**16-2**10-1) + 2**10
  end while usedports.include?(randport)
  randport
end

def scp(dsthost,srcfile,dstfile)
  randport=get_open_port()
  pid=`ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -N -L #{randport}:#{dsthost}:22 #{ENV['USER']}@#{kavlan_gw()} &>/dev/null & echo $!`

  time_start = Time.now
  begin
    tmp = `lsof -i4 | grep LISTEN | grep localhost:#{randport}`
    sleep(0.1)
    msg("SSH tunnel creation on localhost:#{randport} failed",MSG_ERROR,true) \
      if Time.now - time_start > 4
  end while !tmp or tmp.empty?

  `scp -r -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P #{randport} #{srcfile} root@localhost:#{dstfile} |& grep -v 'Warning: Permanently added'`

  `kill #{pid}`
end

def tempfile(content)
  tmp = Tempfile.new(__FILE__)
  tmp.write(content)
  tmp.close

  yield(tmp.path)

  tmp.unlink 
end

def select_type(hash,type)
  hash.select { |n,h| h[:type] == type }.collect { |v| v[1] }
end

options[:node_list]   = nil
options[:debpackages] = []
options[:gempackages] = []
options[:git]         = nil
options[:ssh_key]     = nil
options[:debug]       = false
options[:version]     = nil
options[:daemon_kadeploy] = nil

args = ARGV.dup

optparse = OptionParser.new(USAGE) do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
  		puts opts
  		exit
	end
	
	opts.on( '-n', '--node-list <nodelist_file>', 'Specify a file containing the list of the nodes to be installed' ) do |n|
  	options[:node_list] = n
	end
	
	opts.on( '-d', '--debug', 'Verbose display of every instruction sent' ) do
  	options[:debug] = true
	end
	
	opts.on( '-k', '--ssh-key [<ssh_key_file>]', 'Specify the path of the ssh private key to use' ) do |k|
  	options[:ssh_key] = k
	end
	
	opts.on( '-g', '--git [<git_hash|git_tag>]', "Specify a specific version to install from git repository (if not specified, taking the last revision). Some packages are installed on one of the nodes in order to build the debian package (See `apt-get build-dep kadeploy-server` + deb: #{})" ) do |n|
  	options[:git] = n || :git_last
	end
	
	opts.on( '-p', '--debpackages <package1>,<package2>,<...>', Array, 'Specify additional debian packages to be installed on the frontend' ) do |p|
  	options[:debpackages] = p
	end
	
	#opts.on( '-r', '--gempackages <package1>,<package2>,<...>', Array, 'Specify additional gem packages to be installed on frontend' ) do |p|
  	#options[:gempackages] = p
	#end

	opts.on( '-d', '--kadeploy-daemon <node_address>', 'Specify which node should be used as kadeploy daemon (default: first node)' ) do |d|
  	options[:daemon_kadeploy] = d || nil
	end
end

$startt = Time::now

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  msg(e.to_s,MSG_ERROR,true)
end

if ARGV.size < 1
  msg(USAGE)
  exit 1
end

# Checking kernels directory
msg("invalid directory '#{ARGV[0]}'",MSG_ERROR,true) unless File.directory?(ARGV[0])
deplkernelfiles = Dir.entries(ARGV[0])
deplkernelfiles.delete('.')
deplkernelfiles.delete('..')
vmlinuzfiles = deplkernelfiles.select{ |filename| filename.include?('vmlinuz') }
vmlinuzfiles.each do |vmlinuzfile|
  initrdfile = File.join(ARGV[0],vmlinuzfile.gsub(/vmlinuz/,'initrd'))
  unless File.exist?(initrdfile)
    msg("initrd file for '#{vmlinuzfile}' kernel not found, ignoring kernel",MSG_WARNING)
    next
  end
  name = vmlinuzfile.gsub(/vmlinuz/,'').gsub(/--/,'-')
  $deplkernels[name] = {
    :name => name,
    :vmlinuz => File.join(ARGV[0],vmlinuzfile),
    :initrd => initrdfile
  }
end

msg("no valid deploiement kernel found in #{ARGV[0]}",MSG_ERROR,true) if $deplkernels.empty?


if options[:node_list]
	nodelist_file = options[:node_list]
elsif (ENV['GOOD_NODES'])
	nodelist_file = ENV['GOOD_NODES']
elsif (ENV['OAR_NODEFILE'])
	nodelist_file = ENV['OAR_NODEFILE']
else
  msg("nodelist parameter not set",MSG_ERROR,true)
end

begin
	File.open(nodelist_file, 'r') do |f|
	  f.each{ |line| $allnodes << line.strip unless $allnodes.include?(line.strip) }
	end
rescue Errno::ENOENT
	msg("File '#{nodelist_file}' not found",MSG_ERROR,true)
end

msg("nodelist parameter empty",MSG_ERROR,true) if $allnodes.empty?
$allnodes.sort!

deplnodes = $allnodes.dup

kaserver = options[:deamon_kadeploy] || $allnodes[0]

if deplnodes.include?(kaserver)
	deplnodes.delete(kaserver)
else
  tmp = deplnodes.select { |node| node =~ /^#{kaserver}/ }
 	if tmp.empty?
  	msg("Kadeploy daemon not present in <nodes_file>",MSG_WARNING)
  else
    msg("Kadeploy daemon '#{kaserver}' assumed to be '#{tmp[0]}' (which is present in <nodes_file>)",MSG_WARNING)
    kaserver = tmp[0]
    deplnodes.delete(kaserver)
  end
end

$kanodes[:kadeploy] = {}
$kanodes[:kadeploy][:name] = 'kadeploy'
$kanodes[:kadeploy][:basename] = kaserver
$kanodes[:kadeploy][:type] = :SERVER

# >>> TODO: Add options
$kanodes[:dns] = {}
$kanodes[:dns][:name] = 'dns'
$kanodes[:dns][:basename] = kaserver
$kanodes[:dns][:type] = :SERVER

deplnodes.delete($kanodes[:dns][:basename])
$kanodes[:tftp] = {}
$kanodes[:tftp][:name] = 'tftp'
$kanodes[:tftp][:basename] = kaserver
$kanodes[:tftp][:type] = :SERVER
deplnodes.delete($kanodes[:tftp][:basename])

$kanodes[:dhcp] = {}
$kanodes[:dhcp][:name] = 'dhcp'
$kanodes[:dhcp][:basename] = kaserver
$kanodes[:dhcp][:type] = :SERVER
deplnodes.delete($kanodes[:dhcp][:basename])

$kanodes[:sql] = {}
$kanodes[:sql][:name] = 'sql'
$kanodes[:sql][:basename] = kaserver
$kanodes[:sql][:type] = :SERVER
deplnodes.delete($kanodes[:sql][:basename])

$kanodes[:frontend] = {}
$kanodes[:frontend][:name] = 'frontend'
$kanodes[:frontend][:basename] = kaserver
$kanodes[:frontend][:type] = :SERVER
deplnodes.delete($kanodes[:frontend][:basename])


msg('deploy nodelist empty',MSG_WARNING) if deplnodes.empty?

# Naming deploiement nodes
tmp = 1
deplnodes.each do |node|
  name = "#{NODE_NAME_PREFIX}#{tmp}"
  $kanodes[:"#{name}"] = {}
  $kanodes[:"#{name}"][:name] = name
  $kanodes[:"#{name}"][:basename] = node.strip
  $kanodes[:"#{name}"][:type] = :NODE
  tmp += 1
end

$kanodes.values.collect! do |v|
  v[:fqdn] = "#{v[:name]}.#{DOMAIN}"
  tmp = v[:basename].split('.')[0]
  v[:basenodename] = tmp

  if g5k?
    cluster = tmp.split('-')[0]
  else
    cluster = 'default'
  end

  unless $clusters[cluster]
    $clusters[cluster] = {}
    $clusters[cluster][:basename] = cluster
    $clusters[cluster][:name] = "#{cluster}#{CLUSTER_NAME_SUFIX}"
    $clusters[cluster][:nodes] = []
  end
  $clusters[cluster][:nodes] << v
  v[:cluster] = $clusters[cluster]
end

msg("=== Gathering cluster#{$clusters.size > 1 ? 's' : ''} information",MSG_INFO)
$clusters.values.collect! do |v|
  msg("#{v[:basename]}:",MSG_INFO)
  v[:kernel] = $deplkernels[$deplkernels.keys[0]]
  msg("  kernel: #{v[:kernel][:name]}",MSG_INFO)
  v[:drivers] = {}
  if g5k?
    tmp = nil
    begin
      tmp = JSON.parse(RestClient.get(G5K_API + "/grid5000/sites/#{$site.split('.')[0]}/clusters/#{v[:basename]}/nodes/#{v[:nodes][0][:basenodename]}"))
    rescue Exception
      msg('can\'t gather g5k api information',MSG_WARNING)
    end
    unless !tmp or tmp.empty?
      v[:drivers][:network] = tmp['network_adapters'].select do |na|
        na['device'] == NET_ADMIN_IFACE
      end[0]['driver']
      v[:drivers][:disk] = tmp['storage_devices'][0]['driver']
    end
    tmpfile = File.join(G5K_POSTINSTALLS_PATH,"preinstall-#{v[:basename]}.tgz")
    if File.exist?(tmpfile)
      v[:postinstall] = tmpfile
    else
      msg("cluster #{v[:basename]} preinstall file not found in '#{G5K_POSTINSTALLS_PATH}'",MSG_WARNING)
    end
  end
  v[:drivers][:network] = DEFAULT_NET_DRIVER unless v[:drivers][:network] 
  v[:drivers][:disk] = DEFAULT_DISK_DRIVER unless v[:drivers][:disk] 

  msg("  net driver: #{v[:drivers][:network]}",MSG_INFO)
  msg("  disk driver: #{v[:drivers][:disk]}",MSG_INFO)
end

msg("=== Gathering environements information",MSG_INFO)
if g5k?
  G5K_ENVS.each do |env|
    $kaenvs[env] = {}
    $kaenvs[env][:name] = env
    $kaenvs[env][:dscfile] = File.join(CFG_KADEPLOY_ENVS_DESC_PATH,"#{env}.dsc")
    tmp = `kaenv3 -u deploy -p #{env}`.chomp
    tmp.each do |line|
      if line =~ /^\s*tarball\s*:\s*([^ |]+)\|\S+\s*$/
        $kaenvs[env][:tarball] = Regexp.last_match(1)
      elsif line =~ /^\s*postinstall\s*:\s*([^ |]+)\|([^ |]+)\|(.*)$/
        $kaenvs[env][:postinstall] = {}
        $kaenvs[env][:postinstall][:file] = Regexp.last_match(1)
        $kaenvs[env][:postinstall][:filetype] = Regexp.last_match(2)
        $kaenvs[env][:postinstall][:args] = Regexp.last_match(3)
      elsif line.strip != '###' and !line.strip.empty?
        $kaenvs[env][:desc] = [] unless $kaenvs[env][:desc]
        $kaenvs[env][:desc] << line
      end
    end
    msg("#{$kaenvs[env][:name]}:",MSG_INFO)
    if $kaenvs[env][:tarball]
      msg("  tarball: #{$kaenvs[env][:tarball]}",MSG_INFO)
    else
      msg("can't find env #{env} tarball",MSG_WARNING)
      $kaenvs.delete(env)
    end
    msg("  postinstall: #{$kaenvs[env][:postinstall][:file]}",MSG_INFO) \
      if $kaenvs[env][:postinstall]
  end
end


if options[:ssh_key]
  if File.exists?(options[:ssh_key])
    $sshkeyfile = options[:ssh_key]
  else
    msg("ssh key #{options[:ssh_key]} not found",MSG_ERR,true)
  end
else
  sshkeyfiles = SSH_KEYS.select { |keypath| File.exists?(keypath) }
  if sshkeyfiles.empty?
    msg("no ssh private key file found (specify one with -k)",MSG_ERROR,true)
  else
    $sshkeyfile = sshkeyfiles[0]
  end
end

$kavlan_id = `kavlan --show-vlan-id`

if $?.success? and !$kavlan_id.empty?
  begin 
    Integer($kavlan_id)
  rescue ArgumentError
    msg("kavlan not set",MSG_ERROR,true)
  else
    $kavlan_id = $kavlan_id.to_i
  end
else
  msg("kavlan not set",MSG_ERROR,true)
end

# Disabling DHCP in vlan
`kavlan --disable-dhcp`


Net::SSH.start(kavlan_gw(), ENV['USER'], :keys => $sshkeyfile) do |gwsession|
sshgw = Net::SSH::Gateway.new(kavlan_gw(), ENV['USER'], :keys => $sshkeyfile)

begin
  pubkey = File.open("#{$sshkeyfile}.pub",'r').read
rescue Errno::ENOENT
  msg("user public key file '#{$sshkeyfile}.pub' not found",MSG_WARNING)
else
  tmp = sexec(gwsession,"grep '#{pubkey}' ~#{ENV['USER']}/.ssh/authorized_keys; true;")[0]
   sexec(gwsession,"echo '#{pubkey}' >> ~#{ENV['USER']}/.ssh/authorized_keys") if !tmp or tmp.empty?
end

server=kavlan_node($kanodes[:dns][:basename])
msg('=== Gathering network information',MSG_INFO)
sshgw.ssh(server,'root') do |session|
  msg("Connected to #{server}",MSG_INFO)

  msg('Getting network information',MSG_INFO)
  tmp = sexec(session,'route -n')
  msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
  defaultiface = nil
  tmp.each do |line|
    if line =~ /^(\S+)\s+0\.0\.0\.0\s+(\S+)\s+.+$/ 
      $network[:ipv4] = Regexp.last_match(1)
      $network[:mask] = Regexp.last_match(2)
      $network[:ipaddr] = IPAddr.new("#{$network[:ipv4]}/#{$network[:mask]}")
      $network[:broadcast] = ($network[:ipaddr] | (~$network[:ipaddr].instance_variable_get(:@mask_addr) & IPAddr::IN4MASK)).to_s
    elsif line =~ /^0\.0\.0\.0\s+(\S+)\s+.+\s+(\S+)\s*$/ 
      $network[:gateway] = Regexp.last_match(1)
      defaultiface = Regexp.last_match(2)
    end
  end

  if $network.empty?
    msg('unable to gather network information',MSG_ERROR,true)
  else
    msg('Network config:',MSG_INFO)
    msg("  addresses: #{$network[:ipv4]}/#{$network[:mask]}",MSG_INFO)
    msg("  gateway: #{$network[:gateway]}",MSG_INFO)
    msg("  broadcast: #{$network[:broadcast]}",MSG_INFO)
  end
  msg('can\'t find default network iface',MSG_ERROR,true) if !defaultiface or defaultiface.empty?
  

  msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_create(session,3128,'proxy')

  msg('Updating debian packages list',MSG_INFO)
  apt_update(session)

  msg('Getting nodes IPv4/MAC addresses',MSG_INFO)
  apt_install(session,'syslinux')
  $kanodes.values.each do |node|
    if node == :dns or node[:basename] == $kanodes[:dns][:basename]
      tmp = sexec(session,"ifconfig #{defaultiface}")
      msg('can\'t ifconfig default network iface',MSG_ERROR,true) if !tmp or tmp.empty?
      tmp.each do |line|
        if line.include?('HWaddr')
          node[:mac] = line.split('HWaddr')[1].strip.split[0]
        elsif line.include?('inet addr:')
          node[:ipv4] = line.split('inet addr:')[1].strip.split[0]
        end
      end
    else
      tmp = sexec(session,"gethostip -d #{kavlan_node(node[:basename])}")[0]
      msg("can't get '#{node[:basename]}' IPv4 address",MSG_ERROR,true) if !tmp or tmp.empty?
      node[:ipv4] = tmp

      tmp = sexec(session,"ping -c 1 #{node[:ipv4]} &>/dev/null; arp -n | grep #{node[:ipv4]}")[0]
      msg("can't resolv '#{node[:basename]}' MAC address",MSG_ERROR,true) if !tmp or tmp.empty?
      node[:mac] = tmp.split[2].chomp
    end

    msg("can\'t collect IPv4/MAC on #{node[:basename]}",MSG_ERROR,true) \
      if !node[:mac] or !node[:ipv4] or node[:mac].empty? or node[:ipv4].empty?
  end

  msg('Removing configuration related packages',MSG_INFO)
  apt_remove(session,'syslinux')

  msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_destroy(session,3128,server)
end
msg("Disconnected from #{server}",MSG_INFO)
msg("",MSG_INFO)

server=kavlan_node($kanodes[:dns][:basename])
msg('=== Setting up DNS server',MSG_INFO)
sshgw.ssh(server,'root') do |session|
  msg("Connected to #{server}",MSG_INFO)

  msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_create(session,3128,'proxy')

  msg('Updating debian packages list',MSG_INFO)
  apt_update(session)

  msg('Installing DNS server',MSG_INFO)
  apt_install(session,'bind9')


  msg('Configuring DNS server',MSG_INFO)
  

  tempfile(cfg_dns_master()) {|path| scp(server,path,cfg_bind_master_file())}
  sexec(session,"chown bind #{cfg_bind_master_file()}")

  tempfile(cfg_dns_reverse()) {|path| scp(server,path,cfg_bind_reverse_file())}
  sexec(session,"chown bind #{cfg_bind_reverse_file()}")

=begin
  tmp = sexec(session,"grep '^nameserver' #{CFG_RESOLVCONF_FILE}")[0]
  if !tmp or tmp.empty?
    tmp = ''
    msg('no nameserver in resolv.conf file',MSG_WARNING)
  else
    tmp = tmp.split[1]
  end
=end
  # Assume that default DNS server is the network gateway
  tmp = $network[:gateway]
  tempfile(cfg_bind((tmp != $kanodes[:dns][:ipv4] ? tmp : ''))) do |path|
    scp(server,path,CFG_BIND_NAMED_FILE)
  end
  sexec(session,"chown bind #{CFG_BIND_NAMED_FILE}")

  sexec(session,'service bind9 restart')

  msg('Updating resolv.conf files',MSG_INFO)
  tempfile(cfg_resolvconf()) {|path| scp(server,path,CFG_RESOLVCONF_FILE)}

  $kanodes.each do |name,hash|
    next if name == :dns
    sexec(session,"scp -r -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null #{CFG_RESOLVCONF_FILE} root@#{hash[:ipv4]}:#{CFG_RESOLVCONF_FILE}")
  end

  msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_destroy(session,3128,server)
end
msg("Disconnected from #{server}",MSG_INFO)
msg("",MSG_INFO)


server=kavlan_node($kanodes[:tftp][:basename])
msg('=== Setting up TFTP server',MSG_INFO)
sshgw.ssh(server,'root') do |session|
  msg("Connected to #{server}",MSG_INFO)
  
  msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_create(session,3128,'proxy')


  msg('Updating debian packages list',MSG_INFO)
  apt_update(session)

  msg('Installing TFTP server',MSG_INFO)
  apt_install(session,'debconf-utils')
  sexec(session,"rm -Rf #{CFG_TFTP_PATH}")
  sexec(session,"mkdir -p #{CFG_TFTP_PATH}")
  sexec(session,"echo 'tftpd-hpa tftpd-hpa/directory string #{CFG_TFTP_PATH}' | debconf-set-selections")
  sexec(session,"echo 'tftpd-hpa tftpd-hpa/username string #{CFG_TFTP_USER}' | debconf-set-selections")
  apt_install(session,'tftpd-hpa')

  msg('Configuring TFTP server',MSG_INFO)
  tempfile(cfg_tftp()) {|path| scp(server,path,CFG_TFTP_CONF_FILE)}
  sexec(session,'service tftpd-hpa restart')

  msg('Installing bootfiles',MSG_INFO)
  apt_install(session,'syslinux-common')
  CFG_PXE_BOOTFILES.each do |bootfile|
    tmp = sexec(session,"dpkg -L syslinux-common | grep '^.*/#{bootfile}$'",false,false)
    msg("mandatory bootfile '#{bootfile}' not found in syslinux-common package",
      MSG_ERROR,true) if !tmp or tmp.empty? or !tmp[0] or tmp[0].empty?
    sexec(session,"ln -f #{tmp[0]} #{CFG_TFTP_PATH}")
  end

  msg('Installing deploiement kernels',MSG_INFO)
  sexec(session,"mkdir -p #{CFG_PXE_KERNELS_PATH}")
  $deplkernels.each do |name,kernel|
    msg("  Installing kernel #{name}",MSG_INFO)
    scp(server,kernel[:vmlinuz],CFG_PXE_KERNELS_PATH)
    scp(server,kernel[:initrd],CFG_PXE_KERNELS_PATH)
  end

  msg('Creating pxelinux configs',MSG_INFO)
  sexec(session,"mkdir -p #{CFG_PXE_CONFIG_PATH}")
  #apt_install(session,'syslinux')
  tempfile(cfg_pxe()) do |path|
    select_type($kanodes,:NODE).each do |node|
      #tmp = sexec(session,"gethostip -x #{node[:fqdn]}")[0]
      #msg("gethostip failed for '#{node[:fqdn]}', aborting",MSG_ERROR,true) \
      #  if !tmp or tmp.empty?
      tmp = IPAddr.new(node[:ipv4]).instance_variable_get(:@addr).to_s(16).upcase
      scp(server,path,File.join(CFG_PXE_CONFIG_PATH,tmp))
    end
    scp(server,path,File.join(CFG_PXE_CONFIG_PATH,'default'))
  end

  sexec(session,"chown #{CFG_TFTP_USER}:#{CFG_TFTP_USER} -R #{CFG_TFTP_PATH}")
  sexec(session,"chmod -R 755 #{CFG_TFTP_PATH}")

  msg('Removing configuration related packages',MSG_INFO)
  apt_remove(session,['debconf-utils'])

  msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_destroy(session,3128,server)
end
msg("Disconnected from #{server}\n",MSG_INFO)
msg("",MSG_INFO)


server=kavlan_node($kanodes[:dhcp][:basename])
msg('=== Setting up DHCP server',MSG_INFO)
sshgw.ssh(server,'root') do |session|
  msg("Connected to #{server}",MSG_INFO)
  
  msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_create(session,3128,'proxy')

  msg('Updating debian packages list',MSG_INFO)
  apt_update(session)

  msg('Installing DHCP server',MSG_INFO)
  apt_install(session,'isc-dhcp-server')

  msg('Configuring DHCP server',MSG_INFO)
  tempfile(cfg_dhcp()) {|path| scp(server,path,CFG_DHCP_CONF_FILE)}
  sexec(session,'service isc-dhcp-server restart')

  msg('Reloading network interfaces',MSG_INFO)
  sexec(session,'service networking restart &>/dev/null')
  excls = []
  excls << $kanodes[:dhcp][:ipv4]
  Net::SSH::Multi.start do |bcastsession|
    bcastsession.via kavlan_gw(), ENV['USER']
    $kanodes.each do |name,node|
      unless excls.include?(node[:ipv4])
        bcastsession.use "root@#{node[:ipv4]}"
        excls << node[:ipv4]
      end
    end
    bcastsession.exec('service networking restart &>/dev/null')
  end
  
  msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_destroy(session,3128,server)
end
msg("Disconnected from #{server}\n",MSG_INFO)
msg("",MSG_INFO)


server=kavlan_node($kanodes[:sql][:basename])
msg('=== Setting up SQL server',MSG_INFO)
sshgw.ssh(server,'root') do |session|
  msg("Connected to #{server}",MSG_INFO)
  
  msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_create(session,3128,'proxy')

  msg('Updating debian packages list',MSG_INFO)
  apt_update(session)

  msg('Installing mySQL server',MSG_INFO)
  apt_install(session,'debconf-utils')
  sexec(session,"echo 'mysql-server-#{CFG_MYSQL_VERSION} mysql-server/root_password password #{CFG_SQL_PASS_ROOT}' | debconf-set-selections")
  sexec(session,"echo 'mysql-server-#{CFG_MYSQL_VERSION} mysql-server/root_password_again password #{CFG_SQL_PASS_ROOT}' | debconf-set-selections")
  apt_install(session,'mysql-server')

  msg('Configuring mySQL server',MSG_INFO)
  #sexec("cat #{CFG_MYSQL_CONF_FILE} | sed -e '/bind-address/d' > #{tmp}; mv -f #{tmp} #{CFG_MYSQL_CONF_FILE}")
  tempfile(cfg_mysql()) {|path| scp(server,path,CFG_MYSQL_CONF_FILE)}
  sexec(session,'service mysql restart')
  
  msg('Creating Kadeploy database',MSG_INFO)
  tmp = sexec(session,'tempfile')[0]
  msg('can\'t get temporary file',MSG_ERROR,true) if !tmp or tmp.empty?
  tempfile(cfg_sql()) {|path| scp(server,path,tmp)}
  sexec(session,"mysql --user=root --password=#{CFG_SQL_PASS_ROOT} < #{tmp}")
  sexec(session,"rm #{tmp}")

  msg('Removing configuration related packages',MSG_INFO)
  apt_remove(session,'debconf-utils')

  msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_destroy(session,3128,server)
end
msg("Disconnected from #{server}\n",MSG_INFO)
msg("",MSG_INFO)

server=kavlan_node($kanodes[:kadeploy][:basename])
msg('=== Setting up Kadeploy server',MSG_INFO)
sshgw.ssh(server,'root') do |session|
  msg("Connected to #{server}",MSG_INFO)
  
  msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_create(session,3128,'proxy')

  tmp = sexec(session,"grep '#{DEB_REPOSITORY}' /etc/apt/sources.list",false,false)
  sexec(session,"echo 'deb #{DEB_REPOSITORY} / ' >> /etc/apt/sources.list") \
    if !tmp or tmp.empty?

  msg('Updating debian packages list',MSG_INFO)
  apt_update(session)

  msg('Creating Kadeploy directories',MSG_INFO)
  sexec(session,"touch #{CFG_KADEPLOY_LOGFILE}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_LOGFILE}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_CACHE_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_CACHE_PATH}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_VAR_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_VAR_PATH}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_HOSTNAMES_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_PATH}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_PATH}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_DESC_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_DESC_PATH}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")
  sexec(session,"mkdir -p #{CFG_KADEPLOY_PREINSTALLS_PATH}")
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_PREINSTALLS_PATH}")

  msg('Copying clusters postinstall files',MSG_INFO)
  $clusters.values.each do |cluster|
    postinstallpath = cfg_kadeploy_specific_conf_postinstall_path(cluster)
    if postinstallpath
      scp(server,cluster[:postinstall],postinstallpath)
      sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{postinstallpath}")
    end
  end

  msg('Copying and configuring environments',MSG_INFO)
  $kaenvs.values.each do |env|
    msg("  #{env[:name]} config",MSG_INFO)
    scp(server,env[:tarball],File.join(CFG_KADEPLOY_ENVS_IMAGES_PATH,File.basename(env[:tarball])))
    scp(server,env[:postinstall][:file],File.join(CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH,File.basename(env[:postinstall][:file]))) if env[:postinstall]
    tempfile(cfg_environment_desc(env)) do |path|
      scp(server,path,env[:dscfile])
    end
  end
  sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
  sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_DESC_PATH}")
  sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")

  msg('Installing Kadeploy server/client',MSG_INFO)
  apt_install(session,['kadeploy-server','kadeploy-client'])

  sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_SSHKEY_PATH}")

  msg('Configuring Kadeploy server',MSG_INFO)
  tempfile(cfg_kadeploy_conf()) {|path| scp(server,path,CFG_KADEPLOY_CONF_CONF_FILE)}
  tempfile(cfg_kadeploy_cmd()) {|path| scp(server,path,CFG_KADEPLOY_CMD_CONF_FILE)}
  tempfile(cfg_kadeploy_clusters()) {|path| scp(server,path,CFG_KADEPLOY_CLUSTERS_CONF_FILE)}
  tempfile(cfg_kadeploy_nodes()) {|path| scp(server,path,CFG_KADEPLOY_NODES_CONF_FILE)}
  $clusters.values.each do |cluster|
    filepath = CFG_KADEPLOY_PARTITION_CONF_FILE_PREFIX+cluster[:name]
    tempfile(cfg_kadeploy_partition_file(cluster)) do |path|
      scp(server,path,filepath)
    end
    sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{filepath}")

    filepath = CFG_KADEPLOY_SPECIFIC_CONF_FILE_PREFIX+cluster[:name]
    tempfile(cfg_kadeploy_specific_conf(cluster)) do |path|
      scp(server,path,filepath)
    end
    sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{filepath}")
  end
  sexec(session,'service kadeploy3d restart')

  msg('Configuring Kadeploy client',MSG_INFO)
  tempfile(cfg_kadeploy_client()) do |path|
    scp(server,path,CFG_KADEPLOY_CLIENT_CONF_FILE)
  end
  sexec(session,"chmod +r #{CFG_KADEPLOY_CLIENT_CONF_FILE}")

  msg('Adding environments',MSG_INFO)
  $kaenvs.values.each do |env|
    sexec(session,"kaenv3 -u #{CFG_KADEPLOY_USER} -a #{env[:dscfile]}")
    msg("  #{env[:name]} ok",MSG_INFO)
  end

  msg('Set rights for frontend user',MSG_INFO)
  select_type($kanodes,:NODE).each do |node|
    sexec(session,"karights3 --overwrite-rights -a -m #{node[:fqdn]} -p #{CFG_KADEPLOY_DISK_DEVICE}#{CFG_KADEPLOY_PARTITION_DEPLOY_ID} -u #{CFG_FRONTEND_USER}");
  end

  msg('Setting up hostnames hack',MSG_INFO)
  scp(server,$sshkeyfile,CFG_KADEPLOY_HOSTNAMES_SSHKEY)
  sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_SSHKEY}")
  select_type($kanodes,:NODE).each do |node|
    sexec(session,"echo '#{node[:fqdn]}' > #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,node[:basename])}")
    sexec(session,"echo '#{node[:basename]}' > #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,node[:fqdn])}")
  end
  sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_PATH}")

  msg('Removing configuration related packages',MSG_INFO)
  #apt_remove(session,'kadeploy-client')

  msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_destroy(session,3128,server)
end
msg("Disconnected from #{server}\n",MSG_INFO)
msg("",MSG_INFO)


server=kavlan_node($kanodes[:frontend][:basename])
msg('=== Setting up frontend',MSG_INFO)
sshgw.ssh(server,'root') do |session|
  msg("Connected to #{server}",MSG_INFO)
  
  msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_create(session,3128,'proxy')

  tmp = sexec(session,"grep '#{DEB_REPOSITORY}' /etc/apt/sources.list",false,false)
  sexec(session,"echo 'deb #{DEB_REPOSITORY} / ' >> /etc/apt/sources.list") \
    if !tmp or tmp.empty?

  msg('Updating debian packages list',MSG_INFO)
  apt_update(session)

  msg('Installing Kadeploy client',MSG_INFO)
  apt_install(session,'kadeploy-client')

  msg('Configuring Kadeploy client',MSG_INFO)
  tempfile(cfg_kadeploy_client()) do |path|
    scp(server,path,CFG_KADEPLOY_CLIENT_CONF_FILE)
  end
  sexec(session,"chmod +r #{CFG_KADEPLOY_CLIENT_CONF_FILE}")

  msg('Installing additional packages',MSG_INFO)
  apt_install(session,CFG_FRONTEND_PACKAGES)

  msg("Creating frontend user '#{CFG_FRONTEND_USER}'",MSG_INFO)
  sexec(session,"userdel --force --remove #{CFG_FRONTEND_USER}; true ;")
  sexec(session,"useradd --create-home --user-group --shell \"`which #{CFG_FRONTEND_SHELL}`\" --password '#{CFG_FRONTEND_USER_PASS}' #{CFG_FRONTEND_USER}")

  msg("Generating frontend user ssh key pair",MSG_INFO)
  sexec(session,"mkdir -p ~#{CFG_FRONTEND_USER}/.ssh")
  sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} ~#{CFG_FRONTEND_USER}/.ssh")
  sexec(session,"ssh-keygen -t rsa -f ~#{CFG_FRONTEND_USER}/.ssh/id_rsa -N ''")
  sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} ~#{CFG_FRONTEND_USER}/.ssh/id_rsa")
  sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} ~#{CFG_FRONTEND_USER}/.ssh/id_rsa.pub")
  
  msg("Copying user public key",MSG_INFO)
  begin
    pubkey = File.open("#{$sshkeyfile}.pub",'r').read
  rescue Errno::ENOENT
    msg("user public key file '#{$sshkeyfile}.pub' not found",MSG_WARNING)
  else
    sexec(session,"touch ~#{CFG_FRONTEND_USER}/.ssh/authorized_keys")
    sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} ~#{CFG_FRONTEND_USER}/.ssh/authorized_keys")
    tmp = sexec(session,"grep '#{pubkey}' ~#{CFG_FRONTEND_USER}/.ssh/authorized_keys; true;")[0]
    sexec(session,"echo '#{pubkey}' >> ~#{CFG_FRONTEND_USER}/.ssh/authorized_keys") if !tmp or tmp.empty?
  end

	if options[:debpackages] and !options[:debpackages].empty?
		msg("Installing additional packages '#{options[:debpackages].join(',')}'",MSG_INFO)
		apt_install(session,options[:debpackages])
	end


  msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
  ssh_tunnel_destroy(session,3128,server)
end
msg("Disconnected from #{server}\n",MSG_INFO)
msg("",MSG_INFO)

end

msg("Installation done",MSG_INFO)
msg("Deploiement nodes:")
select_type($kanodes,:NODE).each do |node|
  msg("  #{node[:fqdn]} (#{node[:basename]})")
end
msg("Frontend: #{CFG_FRONTEND_USER}@#{kavlan_node($kanodes[:frontend][:basename])}")

