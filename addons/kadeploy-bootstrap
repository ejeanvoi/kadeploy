#!/usr/bin/ruby

require 'rubygems'
require 'net/ssh/gateway'
require 'net/ssh/multi'
require 'restclient'
require 'json'
require 'tempfile'
require 'ipaddr'
require 'yaml'
require 'optparse'
require 'uri'


def g5k?
  `hostname --fqdn`.chomp =~ /grid5000.fr$/
end

USAGE           = "Usage: #{$0} [options] <deploykernels_directory> <envs_directory>"

SSH_KEYS        = ["#{ENV['HOME']}/.ssh/id_dsa", "#{ENV['HOME']}/.ssh/id_rsa","#{ENV['HOME']}/.ssh/identity"]
SSH_OPTIONS			= '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
HTTP_PROXY_ADDR   = 'proxy'
HTTP_PROXY_PORT   = 3128
DEB_REPOSITORY   	= 'http://apt.grid5000.fr/kadeploy'

if g5k?
  G5K_API       	= 'https://api.grid5000.fr/2.0'
  G5K_POSTINSTALLS_PATH = '/grid5000/preinstalls/'
else
end

DOMAIN = 'testbed.lan'
CLUSTER_NAME_SUFIX = '-cluster'
NODE_NAME_PREFIX = 'node-'

NET_ADMIN_IFACE = 'eth0'
USE_NET_DRIVER = true
USE_DISK_DRIVER = true

KVM_GATEWAY = '192.168.0.254'
# used to get kadeploy debian package on g5k
KVM_G5K_USER = 'lsarzyniec'
KVM_G5K_SITE = 'access.nancy.grid5000.fr'

DEFAULT_CONSOLE_BAUD_RATE = '38400'
DEFAULT_CONSOLE_TTY_ID = '0'
DEFAULT_RAMDISK_SIZE = 800000

# Used when can't auto detect
DEFAULT_NET_DRIVER = 'e1000e'
DEFAULT_DISK_DRIVER = 'sata_nv'

# Update path for devel
UPDATE_PATH_CHECK = {
  'src' => 'kadeploy_server.rb',
  'lib' => 'managers.rb',
}
UPDATE_FORWARD_PORT = 2222
UPDATE_DIR_VAR = 'WORKINGDIR'


# Kadeploy default config
CFG_KADEPLOY_USER = 'deploy'

CFG_KADEPLOY_MACROSTEP1 = { 
  :name => 'SetDeploymentEnv|SetDeploymentEnvUntrusted',
  :retries => 2,
  :timeout => 450
}
CFG_KADEPLOY_MACROSTEP2 = {
  :name => 'BroadcastEnv|BroadcastEnvChain',
  :retries => 1,
  :timeout => 900
}
CFG_KADEPLOY_MACROSTEP3 = [
  {
    :name => 'BootNewEnv|BootNewEnvClassical',
    :retries => 1,
    :timeout => 400
  },
  {
    :name => 'BootNewEnvHardReboot',
    :retries => 1,
    :timeout => 400
  }
]

CFG_KADEPLOY_PARTITION_SWAP_ID = 1
CFG_KADEPLOY_PARTITION_SWAP_SIZE = '4000M'
CFG_KADEPLOY_PARTITION_PROD_ID = 2
CFG_KADEPLOY_PARTITION_PROD_SIZE = '6000M'
CFG_KADEPLOY_PARTITION_DEPLOY_ID = 3
CFG_KADEPLOY_PARTITION_DEPLOY_SIZE = '6000M'
CFG_KADEPLOY_PARTITION_TMP_ID = 5
CFG_KADEPLOY_DISK_DEVICE = '/dev/sda'

CFG_KADEPLOY_PORT = 25300
CFG_KADEPLOY_VERBOSE = 3
CFG_KADEPLOY_CONF_PATH = '/etc/kadeploy3'
CFG_KADEPLOY_VAR_PATH = '/var/lib/kadeploy'
CFG_KADEPLOY_LOGFILE = '/var/log/kadeploy.log'
CFG_KADEPLOY_SSHKEY_PATH = File.join(CFG_KADEPLOY_CONF_PATH,'keys')
CFG_KADEPLOY_SSHKEY_DEFAULT = File.join(CFG_KADEPLOY_SSHKEY_PATH,'id_deploy')
CFG_KADEPLOY_HOSTNAMES_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'hostnames')
CFG_KADEPLOY_HOSTNAMES_SSHKEY = File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'.ssh_key')
CFG_KADEPLOY_ENVS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'envs')
CFG_KADEPLOY_ENVS_IMAGES_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'images')
CFG_KADEPLOY_ENVS_DESC_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'descriptions')
CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH = File.join(CFG_KADEPLOY_ENVS_PATH,'install_scripts')
CFG_KADEPLOY_CACHE_PATH = '/var/cache/kadeploy/cache'
CFG_KADEPLOY_PREINSTALLS_PATH = File.join(CFG_KADEPLOY_VAR_PATH,'preinstalls')

def cfg_environment_desc(env)
  postinstall = ''
  if env[:postinstall]
    postinstall = "postinstall : #{File.join(CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH,File.basename(env[:postinstall][:file]))}|#{env[:postinstall][:filetype]}|#{env[:postinstall][:args]}\n"
  end

  "###\n"\
  "name : #{env[:name]}\n"\
  "#{env[:desc]}\n"\
  "tarball : #{File.join(CFG_KADEPLOY_ENVS_IMAGES_PATH,File.basename(env[:tarball]))}|tgz\n"\
  + postinstall
end

CFG_KADEPLOY_CLIENT_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'client_conf')
def cfg_kadeploy_client()
  "default = kadeploy\n"\
  "kadeploy = #{$kanodes[:kadeploy][:fqdn]}:#{CFG_KADEPLOY_PORT}\n"
end


def cfg_kadeploy_macrostep(macrostep)
  ret = ''
  if macrostep.is_a?(Array)
    tmp = []
    macrostep.each do |step|
      tmp << cfg_kadeploy_macrostep(step)
      ret = tmp.join(',')
    end
  elsif macrostep.is_a?(Hash)
    ret = "#{macrostep[:name]}:#{macrostep[:retries]}:#{macrostep[:timeout]}"
  elsif macrostep.is_a?(String)
    ret = macrostep
  end
  ret
end

CFG_KADEPLOY_CONF_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'conf')
def cfg_kadeploy_conf()
  "verbose_level = #{CFG_KADEPLOY_VERBOSE}\n"\
  "tftp_repository = #{CFG_TFTP_PATH}\n"\
  "tftp_images_path = #{CFG_TFTP_KERNELS_DIR}\n"\
  "tftp_images_max_size = 600\n"\
  "tftp_cfg = #{CFG_TFTP_PXECONFIG_DIR}\n"\
  "db_kind = mysql\n"\
  "deploy_db_host = #{$kanodes[:sql][:fqdn]}\n"\
  "deploy_db_name = #{CFG_SQL_DB}\n"\
  "deploy_db_login = #{CFG_SQL_USER}\n"\
  "deploy_db_passwd = #{CFG_SQL_PASS_USER}\n"\
  "rights_kind = db\n"\
  "taktuk_connector = ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=publickey -o BatchMode=yes -i #{CFG_KADEPLOY_SSHKEY_DEFAULT}\n"\
  "taktuk_tree_arity = 0\n"\
  "taktuk_auto_propagate = true\n"\
  "tarball_dest_dir = /tmp\n"\
  "environment_extraction_dir = /mnt/dest\n"\
  "kadeploy_server = #{$kanodes[:kadeploy][:fqdn]}\n"\
  "kadeploy_server_port = #{CFG_KADEPLOY_PORT}\n"\
  "kadeploy_tcp_buffer_size = 8192\n"\
  "kadeploy_cache_dir = #{CFG_KADEPLOY_CACHE_PATH}\n"\
  "kadeploy_cache_size = 8000\n"\
  "ssh_port = 22\n"\
  "rsh_port = 514\n"\
  "test_deploy_env_port = #{CFG_KADEPLOY_PORT}\n"\
  "use_rsh_to_deploy = false\n"\
  "log_to_file = #{CFG_KADEPLOY_LOGFILE}\n"\
  "log_to_syslog = true\n"\
  "log_to_db = true\n"\
  "dbg_to_syslog = true\n"\
  "dbg_to_syslog_level = 3\n"\
  "reboot_window = 80\n"\
  "reboot_window_sleep_time = 10\n"\
  "nodes_check_window = 100\n"\
  "bootloader = chainload_pxe\n"\
  "purge_deployment_timer = 900\n"\
  "rambin_path = /rambin\n"\
  "mkfs_options = ext2@-b 4096 -O sparse_super,filetype,resize_inode,dir_index|ext3@-b 4096 -O sparse_super,filetype,resize_inode,dir_index\n"\
  "demolishing_env_threshold = 2\n"\
  "demolishing_env_auto_tag = false\n"\
  "bt_download_timeout = 1800\n"\
  "almighty_env_users = root,oar,deploy\n"\
  "max_preinstall_size = 10\n"\
  "max_postinstall_size = 10\n"\
  "vlan_hostname_suffix = -kavlan-VLAN_ID\n"
  #"async_end_of_deployment_hook = \n"\
  #"set_vlan_cmd = \n"
  # >>> TODO: add Bitorrent support in bootstrap
  #"bt_tracker_ip = \n"\
end

CFG_KADEPLOY_CMD_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'cmd')
def cfg_kadeploy_cmd()
  "\n"
end

CFG_KADEPLOY_CLUSTERS_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'clusters')
def cfg_kadeploy_clusters()
  cfg = ''
  $clusters.values.each do |cluster|
    cfg += "#{cluster[:name]}\n"
  end
  cfg
end

CFG_KADEPLOY_NODES_CONF_FILE = File.join(CFG_KADEPLOY_CONF_PATH,'nodes')
def cfg_kadeploy_nodes()
  nodescfg = ''
  select_type($kanodes,:NODE).each do |node|
    nodescfg += "#{node[:fqdn]} #{node[:ipv4]} #{node[:cluster][:name]}\n"
  end
  nodescfg
end

CFG_KADEPLOY_PARTITION_CONF_FILE_PREFIX = File.join(CFG_KADEPLOY_CONF_PATH,'partition_file_')
def cfg_kadeploy_partition_file(cluster)
  # delete partitions
  "d\n1\nd\n2\nd\n3\nd\n4\n"\
  + # create swap partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_SWAP_ID}\n\n+#{CFG_KADEPLOY_PARTITION_SWAP_SIZE}\nt\n82\n"\
  + # create prod partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_PROD_ID}\n\n+#{CFG_KADEPLOY_PARTITION_PROD_SIZE}\nt\n#{CFG_KADEPLOY_PARTITION_PROD_ID}\n83\n"\
  + # create deploy partition
  "n\np\n#{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\n\n+#{CFG_KADEPLOY_PARTITION_DEPLOY_SIZE}\nt\n#{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\nPARTTYPE\n"\
  + # create tmp partition
  "n\ne\n\n\nn\n\n\nt\n#{CFG_KADEPLOY_PARTITION_TMP_ID}\n83\n"\
  + # write changes
  "p\nw\n"\
  "\n"
end

def cfg_kadeploy_specific_conf_postinstall_path(cluster)
  postinstall = nil
  if cluster[:postinstall]
    postinstall = File.join(CFG_KADEPLOY_PREINSTALLS_PATH,"postinstall-#{cluster[:name]}.tgz")
  end
  postinstall 
end

def cfg_kadeploy_kapower_cmd(cmd)
  "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} #{ENV['USER']}@#{getgw()} \"kapower3 -m `cat #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'HOSTNAME_FQDN')}` #{cmd}\""
end

def cfg_kadeploy_kaconsole_cmd()
  "ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_HOSTNAMES_SSHKEY} #{ENV['USER']}@#{getgw()} \"kaconsole3 -m `cat #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,'HOSTNAME_FQDN')}`\""
end

CFG_KADEPLOY_SPECIFIC_CONF_FILE_PREFIX = File.join(CFG_KADEPLOY_CONF_PATH,'specific_conf_')
def cfg_kadeploy_specific_conf(cluster)
  postinstallpath = cfg_kadeploy_specific_conf_postinstall_path(cluster)
  "deploy_kernel = #{File.basename(cluster[:kernel][:vmlinuz])}\n"\
  + # >>> TODO: UPDATE
  "deploy_initrd = #{File.basename(cluster[:kernel][:initrd])} #{USE_NET_DRIVER ? "ETH_DRV=#{cluster[:drivers][:network]} " : ''}ETH_DEV=#{$netiface} #{USE_DISK_DRIVER ? "DISK_DRV=#{cluster[:drivers][:disk]} " : ''}console=tty#{DEFAULT_CONSOLE_TTY_ID} console=ttyS#{DEFAULT_CONSOLE_TTY_ID},#{DEFAULT_CONSOLE_BAUD_RATE}n8 ramdisk_size=#{DEFAULT_RAMDISK_SIZE} rw noapic init=/linuxrc\n"\
  "block_device = #{CFG_KADEPLOY_DISK_DEVICE}\n"\
  "prod_part = #{CFG_KADEPLOY_PARTITION_PROD_ID}\n"\
  "deploy_part = #{CFG_KADEPLOY_PARTITION_DEPLOY_ID}\n"\
  "tmp_part = #{CFG_KADEPLOY_PARTITION_TMP_ID}\n"\
  "swap_part = #{CFG_KADEPLOY_PARTITION_SWAP_ID}\n"\
  + # Kareboot
  "timeout_reboot_classical = 250\n"\
  "timeout_reboot_kexec = 100\n"\
  "cmd_soft_reboot = ssh -q -o BatchMode=yes -o StrictHostKeyChecking=no -o PreferredAuthentications=publickey -o ConnectTimeout=2 -o SetupTimeOut=5 -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_SSHKEY_DEFAULT} root@HOSTNAME_FQDN \"nohup /sbin/reboot -f >/dev/null &\"\n"\
  "cmd_hard_reboot = #{cfg_kadeploy_kapower_cmd('--off')}; #{cfg_kadeploy_kapower_cmd('--on')};\n"\
  + # Kapower
  "cmd_hard_power_on = #{cfg_kadeploy_kapower_cmd('--on')}\n"\
  "cmd_soft_power_off = ssh -q -o BatchMode=yes -o StrictHostKeyChecking=no -o PreferredAuthentications=publickey -o ConnectTimeout=2 -o SetupTimeOut=5 -o UserKnownHostsFile=/dev/null -i #{CFG_KADEPLOY_SSHKEY_DEFAULT} root@HOSTNAME_FQDN \"nohup /sbin/halt &>/dev/null &\"\n"\
  "cmd_hard_power_off = #{cfg_kadeploy_kapower_cmd('--off')}\n"\
  "cmd_power_status = #{cfg_kadeploy_kapower_cmd('--status')}\n"\
  + # Kaconsole
  "cmd_console = #{cfg_kadeploy_kaconsole_cmd()}\n"\
  "kernel_params = console=tty#{DEFAULT_CONSOLE_TTY_ID} console=ttyS#{DEFAULT_CONSOLE_TTY_ID},#{DEFAULT_CONSOLE_BAUD_RATE}n8\n"\
  + # >>> TODO: UPDATE
  "partition_creation_kind = fdisk\n"\
  "pxe_header = #{CFG_PXE_HEADER.gsub("\n",'\n')}\n"\
  + #Automata description
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP1)}\n"\
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP2)}\n"\
  "macrostep = #{cfg_kadeploy_macrostep(CFG_KADEPLOY_MACROSTEP3)}\n"\
  + (postinstallpath ? "admin_post_install = #{postinstallpath}|tgz|none\n" : '')
  #"nfsroot_kernel = \n"\
  #"nfsroot_params = \n"\
  #cmd_very_hard_power_off = /usr/sbin/pdumix -n HOSTNAME_FQDN -d
  #cmd_soft_power_on = /usr/sbin/pdumix -n HOSTNAME_FQDN -u
end

# frontend default config
CFG_FRONTEND_USER = 'testuser'
CFG_FRONTEND_USER_PASS = 'pass'
CFG_FRONTEND_SHELL = 'bash'
CFG_FRONTEND_PACKAGES = [
]


# TFTP default config
CFG_TFTP_PATH = '/var/lib/tftpboot'
CFG_TFTP_USER = CFG_KADEPLOY_USER
CFG_TFTP_CONF_FILE = '/etc/default/tftpd-hpa'
CFG_TFTP_PXECONFIG_DIR = 'pxelinux.cfg'
CFG_TFTP_KERNELS_DIR = 'kernels'

def cfg_tftp()
  "# /etc/default/tftpd-hpa\n"\
  "TFTP_USERNAME=\"#{CFG_TFTP_USER}\"\n"\
  "TFTP_DIRECTORY=\"#{CFG_TFTP_PATH}\"\n"\
  "TFTP_ADDRESS=\"0.0.0.0:69\"\n"\
  "TFTP_OPTIONS=\"-l -s -c\"\n"
end


# PXE default config
CFG_PXE_DISK='hd0'
CFG_PXE_PART=3
CFG_PXE_KERNEL='chain.c32'
CFG_PXE_BOOTFILES = [
  'chain.c32',
  'mboot.c32',
  'pxelinux.0',
]
CFG_PXE_CONFIG_PATH = File.join(CFG_TFTP_PATH,CFG_TFTP_PXECONFIG_DIR)
CFG_PXE_KERNELS_PATH = File.join(CFG_TFTP_PATH,CFG_TFTP_KERNELS_DIR)
CFG_PXE_HEADER = \
  "PROMPT 1\n"\
  "SERIAL 0 #{DEFAULT_CONSOLE_BAUD_RATE}\n"\
  "DEFAULT bootlabel\n"\
  "DISPLAY messages\n"\
  "TIMEOUT 50\n\n"\
  "label bootlabel\n"

def cfg_pxe(bootkernel=CFG_PXE_KERNEL,bootdisk=CFG_PXE_DISK,bootpart=CFG_PXE_PART)
  CFG_PXE_HEADER +
  "KERNEL #{bootkernel}\n"\
  "APPEND #{bootdisk} #{bootpart}\n"
end


# DNS default config
def cfg_dns_masknb()
  4 - (IPAddr.new($network[:mask]).to_i.to_s(2).count('1') / 8)
end

def cfg_dns_master_node(node)
  nodecfg = "#{node[:name]}      IN    A    #{node[:ipv4]}\n"
  nodecfg += "#{node[:name]}.#{node[:cluster][:name]}      IN    A    #{node[:ipv4]}\n" if node[:type] == :NODE
  nodecfg
end

def cfg_dns_reverse_node(node)
  ip = node[:ipv4].split('.')[-cfg_dns_masknb()..-1].reverse.join('.')
  "#{ip}    IN    PTR    #{node[:fqdn]}.\n"
end

def cfg_dns_base()
  "$TTL 3h\n"\
  "@    IN    SOA    #{$kanodes[:dns][:fqdn]}. postmaster.#{$kanodes[:dns][:fqdn]}. (\n"\
  "  #{Time.now.strftime("%Y%m%d%H%M%S")}\n"\
  "  4h\n"\
  "  1h\n"\
  "  4w\n"\
  "  1h\n"\
  ")\n"
end

def cfg_dns_master()
  nodescfg = ''
  $kanodes.each do |n,h|
    nodescfg += "#{cfg_dns_master_node(h)}\n"
  end

  "#{cfg_dns_base()}\n"\
  "@         IN    NS    #{$kanodes[:dns][:fqdn]}.\n"\
  "@         IN    A     #{$kanodes[:kadeploy][:ipv4]}\n"\
  + nodescfg
end

def cfg_dns_reverse()
  nodescfg = ''
  excls = []
  nodescfg += "#{cfg_dns_reverse_node($kanodes[:kadeploy])}\n"
  excls << $kanodes[:kadeploy][:ipv4]
  $kanodes.each do |n,h|
    unless excls.include?(h[:ipv4])
      nodescfg += "#{cfg_dns_reverse_node(h)}\n"
      excls << h[:ipv4]
    end
  end

  "#{cfg_dns_base()}\n"\
  "@         IN    NS    #{$kanodes[:dns][:fqdn]}.\n"\
  + nodescfg
end


# Bind9 default config
CFG_BIND_PATH='/etc/bind'
CFG_BIND_NAMED_FILE = File.join(CFG_BIND_PATH,'named.conf')
CFG_BIND_CONFIG_FILE_PREFIX = File.join(CFG_BIND_PATH,'db.')

def cfg_bind_reverse_domain()
 $network[:ipv4].to_s.split('.')[0..(4-cfg_dns_masknb()-1)].reverse.join('.')
end

def cfg_bind_reverse_file()
  "#{CFG_BIND_CONFIG_FILE_PREFIX}#{cfg_bind_reverse_domain()}"
end

def cfg_bind_master_file()
  "#{CFG_BIND_CONFIG_FILE_PREFIX}#{DOMAIN}"
end

def cfg_bind(dnsfwd)
  "zone \"#{DOMAIN}\" {\n"\
  "  type master;\n"\
  "  file \"#{cfg_bind_master_file()}\";\n"\
  "};\n\n"\
  "zone \"#{cfg_bind_reverse_domain()}.in-addr.arpa\" {\n"\
  "  type master;\n"\
  "  file \"#{cfg_bind_reverse_file()}\";\n"\
  "};\n"\
  "#{(dnsfwd.empty? ? '' : \
    "options {\n"\
    "  forwarders {\n"\
    "    #{dnsfwd};\n"\
    "  };\n"\
    "};\n"\
  )}"
end


# Resolv.conf default config
CFG_RESOLVCONF_FILE = '/etc/resolv.conf'

def cfg_resolvconf()
  "domain #{DOMAIN}\n"\
  "search #{DOMAIN}\n"\
  "nameserver #{$kanodes[:dns][:ipv4]}\n"
end


# DHCP default config
CFG_DHCP_CONF_FILE='/etc/dhcp/dhcpd.conf'
CFG_DHCP_PXE_MAGIC='F1:00:74:7E'
def cfg_dhcp_node(node)
  "  host #{node[:fqdn]} {\n"\
  "    hardware ethernet #{node[:mac]};\n"\
  "    fixed-address #{node[:ipv4]};\n"\
  "    option host-name \"#{node[:name]}\";\n"\
  "  }\n"
end

def cfg_dhcp()
  nodescfg = ''
  excls = []
  nodescfg += "#{cfg_dhcp_node($kanodes[:kadeploy])}\n"
  excls << $kanodes[:kadeploy][:ipv4]
  $kanodes.each do |n,h|
    unless excls.include?(h[:ipv4])
      nodescfg += "#{cfg_dhcp_node(h)}\n"
      excls << h[:ipv4]
    end
  end

  "default-lease-time 28800;\n"\
  "max-lease-time	86400;\n"\
  + # specific boot options
  "allow booting;\n"\
  "allow bootp;\n\n"\
  "not-authoritative;\n\n"\
  "use-host-decl-names on;\n\n"\
  "log-facility local7;\n\n"\
  + # PXE class options
  "option space PXE;\n"\
  "option PXE.mtftp-ip code 1 = ip-address;\n"\
  "option PXE.mtftp-cport code 2 = unsigned integer 16;\n"\
  "option PXE.mtftp-sport code 3 = unsigned integer 16;\n"\
  "option PXE.mtftp-tmout code 4 = unsigned integer 8;\n"\
  "option PXE.mtftp-delay code 5 = unsigned integer 8;\n"\
  "option PXE.discovery-control code 6 = unsigned integer 8;\n"\
  "option PXE.discovery-mcast-addr code 7 = ip-address;\n\n"\
  + # pxelinux options
  "option space pxelinux;\n"\
  "option pxelinux.magic code 208 = string;\n"\
  "option pxelinux.configfile code 209 = text;\n"\
  "option pxelinux.pathprefix code 210 = text;\n"\
  "option pxelinux.reboottime code 211 = unsigned integer 32;\n"\
  "site-option-space \"pxelinux\";\n"\
  "option pxelinux.magic #{CFG_DHCP_PXE_MAGIC};\n"\
  "option pxelinux.reboottime 30;\n\n"\
  + # PXE class
  "class \"PXE\" {\n"\
	"  match if substring(option vendor-class-identifier, 0, 9) = \"PXEClient\";\n"\
  "  filename \"pxelinux.0\";\n"\
  "  option vendor-class-identifier \"PXEClient\";\n"\
  "  vendor-option-space PXE;\n"\
	"  option PXE.mtftp-ip 0.0.0.0;\n"\
  "}\n\n"\
  + # Experiments network
  "subnet #{$network[:ipv4]} netmask #{$network[:mask]} {\n"\
  "  option subnet-mask #{$network[:mask]};\n"\
  "  option broadcast-address #{$network[:broadcast]};\n"\
  "  option routers #{$network[:gateway]};\n"\
  "  option domain-name \"#{DOMAIN}\";\n"\
  "  option domain-name-servers #{$kanodes[:dns][:ipv4]};\n"\
  + # Kadeploy server
  "  next-server #{$kanodes[:tftp][:ipv4]};\n\n"\
  + # Deploiement nodes
  ""\
  + nodescfg +
  "}\n"
end



# SQL default config
CFG_SQL_USER = CFG_KADEPLOY_USER
CFG_SQL_DB = 'deploy3'
CFG_SQL_PASS_ROOT = 'kadeploy'
CFG_SQL_PASS_USER = "#{CFG_KADEPLOY_USER}-pass"

def cfg_sql()
  # Cleaning up
  "DROP DATABASE IF EXISTS #{CFG_SQL_DB};\n"\
  + # Kadeploy database
  "CREATE DATABASE #{CFG_SQL_DB};\n"\
  + # Kadeploy user
  "GRANT ALL ON #{CFG_SQL_DB}.* TO '#{CFG_SQL_USER}'@'#{$kanodes[:kadeploy][:fqdn]}' IDENTIFIED BY '#{CFG_SQL_PASS_USER}';\n"\
  + # Kadeploy tables, table environments
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`environments` (\n"\
  "  `id` int(10) unsigned NOT NULL auto_increment,\n"\
  "  `name` varchar(255) NOT NULL default '',\n"\
  "  `version` int(10) unsigned NOT NULL default '0',\n"\
  "  `description` text,\n"\
  "  `author` varchar(56) NOT NULL default '',\n"\
  "  `tarball` varchar(512) NOT NULL,\n"\
  "  `preinstall` varchar(512) NOT NULL,\n"\
  "  `postinstall` varchar(512) NOT NULL,\n"\
  "  `hypervisor` varchar(255) NOT NULL,\n"\
  "  `hypervisor_params` varchar(255) NOT NULL,\n"\
  "  `initrd` varchar(255) NOT NULL,\n"\
  "  `kernel` varchar(255) NOT NULL,\n"\
  "  `kernel_params` varchar(255) NOT NULL,\n"\
  "  `fdisk_type` varchar(2) default NULL,\n"\
  "  `filesystem` varchar(9) default NULL,\n"\
  "  `user` varchar(255) default 'nobody',\n"\
  "  `allowed_users` varchar(512) NOT NULL,\n"\
  "  `environment_kind` varchar(10) NOT NULL,\n"\
  "  `visibility` varchar(8) NOT NULL,\n"\
  "  `demolishing_env` int(8) NOT NULL default '0',\n"\
  "  PRIMARY KEY  (`id`)\n"\
  ") ENGINE=MyISAM  DEFAULT CHARSET=utf8;\n"\
  + # table log
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`log` (\n"\
  "  `deploy_id` varchar(41) NOT NULL,\n"\
  "  `hostname` varchar(256) NOT NULL,\n"\
  "  `step1` varchar(45) NOT NULL,\n"\
  "  `step2` varchar(45) NOT NULL,\n"\
  "  `step3` varchar(45) NOT NULL,\n"\
  "  `timeout_step1` smallint(5) unsigned NOT NULL,\n"\
  "  `timeout_step2` smallint(5) unsigned NOT NULL,\n"\
  "  `timeout_step3` smallint(5) unsigned NOT NULL,\n"\
  "  `retry_step1` tinyint(1) unsigned NOT NULL,\n"\
  "  `retry_step2` tinyint(1) unsigned NOT NULL,\n"\
  "  `retry_step3` tinyint(1) unsigned NOT NULL,\n"\
  "  `start` int(10) unsigned NOT NULL,\n"\
  "  `step1_duration` int(10) unsigned NOT NULL,\n"\
  "  `step2_duration` int(10) unsigned NOT NULL,\n"\
  "  `step3_duration` int(10) unsigned NOT NULL,\n"\
  "  `env` varchar(64) NOT NULL,\n"\
  "  `anonymous_env` varchar(6) NOT NULL,\n"\
  "  `md5` varchar(35) NOT NULL,\n"\
  "  `success` varchar(6) NOT NULL,\n"\
  "  `error` varchar(255) NOT NULL,\n"\
  "  `user` varchar(16) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # table nodes
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`nodes` (\n"\
  "  `hostname` varchar(256) NOT NULL,\n"\
  "  `state` varchar(16) NOT NULL,\n"\
  "  `env_id` int(10) NOT NULL,\n"\
  "  `date` int(10) unsigned NOT NULL,\n"\
  "  `user` varchar(16) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # rights
  "CREATE TABLE IF NOT EXISTS #{CFG_SQL_DB}.`rights` (\n"\
  "  `user` varchar(30) NOT NULL,\n"\
  "  `node` varchar(256) NOT NULL,\n"\
  "  `part` varchar(50) NOT NULL\n"\
  ") ENGINE=MyISAM DEFAULT CHARSET=utf8;\n"\
  + # Kadeploy rights
  "INSERT INTO #{CFG_SQL_DB}.rights (user,node,part) VALUES('root','*','*');\n"\
  "FLUSH PRIVILEGES;\n"
end


# mySQL default config
CFG_MYSQL_CONF_FILE = '/etc/mysql/my.cnf'
CFG_MYSQL_VERSION = '5.1'
CFG_MYSQL_PORT = 3306

def cfg_mysql()
  "[client]\n"\
  "port = #{CFG_MYSQL_PORT}\n"\
  "\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "[mysqld_safe]\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "nice = 0\n"\
  "\n"\
  "[mysqld]\n"\
  "user = mysql\n"\
  "pid-file = /var/run/mysqld/mysqld.pid\n"\
  "socket = /var/run/mysqld/mysqld.sock\n"\
  "port = #{CFG_MYSQL_PORT}\n"\
  "basedir = /usr\n"\
  "datadir = /var/lib/mysql\n"\
  "tmpdir = /tmp\n"\
  "language = /usr/share/mysql/english\n"\
  "skip-external-locking\n"\
  "query_cache_limit = 1M\n"\
  "query_cache_size = 16M\n"\
  "expire_logs_days = 10\n"\
  "max_binlog_size = 100M\n"\
  "\n"\
  "[mysqldump]\n"\
  "quick\n"\
  "quote-names\n"\
  "max_allowed_packet = 16M\n"\
  "\n"\
  "[mysql]\n"\
  "no-auto-rehash\n"\
  "\n"\
  "[isamchk]\n"\
  "key_buffer = 16M\n"
end




if g5k?
  $site = `hostname --fqdn`.chomp.split('.',2)[1]
else
  $site = nil
end
$srchost = `hostname --fqdn`.strip


$mode = :KAVLAN
$allnodes=[]
$kanodes={}
$kaenvs={}
$clusters={}
$deplkernels = {}
$stunnels = {}
$hostscache = {}
$network = {}

options = {}

MSG_ERROR=0
MSG_WARNING=1
MSG_INFO=2

def msg(str, type=nil, quit=false)
  case type
  when MSG_ERROR
    puts("### Error: #{str} ###")
  when MSG_WARNING
    puts("### Warning: #{str} ###")
  when MSG_INFO
    puts("[#{(Time.now - $startt).to_i}] #{str}")
  else
    puts str
  end
  exit 1 if quit
end

def kavlan_gw()
  "kavlan-#{$kavlan_id}#{$site.empty? ? '' : ".#{$site}"}"
end

def kavlan_node(name)
  "#{name.split('.')[0]}-#{kavlan_gw()}"
end

def kvm_gw()
	$network[:gateway] || KVM_GATEWAY
end

def getgw()
	ret = nil
	case $mode
		when :KAVLAN
			ret = kavlan_gw()
		when :KVM
			ret = kvm_gw()
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
	ret
end

def getnode(name)
	ret = nil
	case $mode
		when :KAVLAN
			ret = kavlan_node(name)
		when :KVM
			ret = name
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
	ret
end

def gethostbysession(session,address = false)
  unless $hostscache[session]
    $hostscache[session] = {}
		$hostscache[session][:name] =
			sexec(session,'hostname',true,true,false,false)[0].chomp
		$hostscache[session][:address] =
			sexec(session,'hostname -i',true,true,false,false)[0].chomp
  end
	if address
		$hostscache[session][:address]
	else
		$hostscache[session][:name]
	end
end

def sexec(session, cmd, critical = true, showerr = true, showout = false, checkhost = true)
  outs = []
  errs = []
  if checkhost
    host = gethostbysession(session)
  else
    host = session.host
  end
  
  chtmp = session.open_channel do |channel|
    channel.exec(cmd) do |ch, success|
      unless success
        msg("unable to execute '#{cmd}' on #{host}",MSG_ERROR)
      end
      msg("Executing '#{cmd}' on #{host}]",MSG_INFO) \
        if $debug
  
      channel.on_data do |ch,data|
        outs += data.strip.split("\n").collect!{|l| l.strip}
        msg("[#{host}] #{data.strip}") \
          if $debug or showout
      end
      
      channel.on_extended_data do |ch,type,data|
        errs += data.strip.split("\n").collect!{|l| l.strip}
      end
      
      channel.on_request("exit-status") do |ch, data|
        status = data.read_long
        if status != 0 and showerr
          msg("exec of '#{cmd}' on #{host} failed " \
            "with return status #{status.to_s}",MSG_ERROR)
          msg("---stdout dump---")
          outs.each { |out| msg(out) } unless outs.empty?
          msg("---stderr dump---")
          errs.each { |err| msg(err) } unless errs.empty?
          msg("---\n")
          exit 1 if critical
        end
      end

      #channel.wait
    end
  end
  
  chtmp.wait

  outs
end

SSH_TUNNEL_TIMEOUT=20
def ssh_tunnel_create(session,dstport,dsthost,srcport=nil,srchost=nil)
  srcport = dstport unless srcport
  srchost = gethostbysession(session,true) unless srchost

  unless $stunnels["#{srchost}:#{srcport}"]
    # Copying ssh private key on gateway
    scp(srchost,$sshkeyfile,'.ssh/')
    # Kill already existing process listening on srcport
    tmp = sexec(session,"lsof -i4 | grep LISTEN | grep localhost:#{srcport}",false,false)[0]
    if tmp and !tmp.empty?
      msg("A process is already listening on port #{srcport}, trying to kill it",MSG_WARNING)
      sexec(session,"kill #{tmp.chomp.split[1]}")
      time_start = Time.now
      begin
        tmp = sexec(session,"lsof -i4 | grep LISTEN | grep localhost:#{srcport}",false,false)[0]
        sexec(session,"kill -9 #{tmp.chomp.split[1]}") if (Time.now - time_start) > 2
        msg("Killing process that listen on #{srchost}:#{srcport} failed",MSG_ERROR,true) if Time.now - time_start > SSH_TUNNEL_TIMEOUT
        sleep(0.1)
      end until !tmp or tmp.empty?
    end

    $stunnels["#{srchost}:#{srcport}"] = {}
    $stunnels["#{srchost}:#{srcport}"][:dsthost] = dsthost
    $stunnels["#{srchost}:#{srcport}"][:dstport] = dstport
    #$stunnels["#{srchost}:#{srcport}"][:thread] = Thread.new do 

#gwsession = Net::SSH::Gateway.new(kavlan_gw(), ENV['USER'], :keys => $sshkeyfile)
#gwsession.ssh(kavlan_node($kaserver),'root') do |mysession|
      sexec(session,"ssh #{SSH_OPTIONS} -N -L #{srcport}:#{dsthost}:#{dstport} #{ENV['USER']}@#{getgw()} -i #{File.join('.ssh',File.basename($sshkeyfile))} &>/dev/null &")
#end
#    end
#    $stunnels["#{srchost}:#{srcport}"][:thread].run
    time_start = Time.now
    begin
      tmp = sexec(session,"lsof -i4 | grep LISTEN | grep localhost:#{srcport}",false,false)[0]
      sleep(0.1)
      msg("SSH tunnel creation on #{srchost}:#{srcport} failed",MSG_ERROR,true) if Time.now - time_start > SSH_TUNNEL_TIMEOUT
    end while !tmp or tmp.empty?
    $stunnels["#{srchost}:#{srcport}"][:pid] = tmp.split[1]
  else
    if $stunnels["#{srchost}:#{srcport}"][:dsthost] != dsthost \
      or $stunnels["#{srchost}:#{srcport}"][:dstport] != dstport
      msg("Trying to create two tunnels on the same local port (#{srcport})",MSG_WARNING)
    end
  end
end
=begin
      chtmp = session.open_channel do |channel|
        channel.exec("ssh -o StrictHostKeyChecking=no -N -L #{srcport}:#{dsthost}:#{dstport} #{ENV['USER']}@#{kavlan_gw()}") do |ch,success|
        end
      end
      $stunnels["#{srchost}:#{srcport}"][:channel] = chtmp
      chtmp.wait
=end

def ssh_tunnel_destroy(session,srcport,srchost)
  if $stunnels["#{srchost}:#{srcport}"]
    # Removing ssh private key
    sexec(session,"rm -f #{File.join('.ssh',File.basename($sshkeyfile))}")
    if $stunnels["#{srchost}:#{srcport}"][:pid]
      tmp = sexec(session,"ps -p #{$stunnels["#{srchost}:#{srcport}"][:pid]}",false,false)
      if tmp and tmp[1] and !tmp[1].chomp.empty?
        sexec(session,"kill #{$stunnels["#{srchost}:#{srcport}"][:pid]}")
      end
    end
#    $stunnels["#{srchost}:#{srcport}"][:thread].kill
#    $stunnels["#{srchost}:#{srcport}"][:thread].join
    $stunnels.delete("#{srchost}:#{srcport}")
  end
end

=begin
def ssh_tunnels_destroy()
  $stunnels.values.each do |tunnel|
    #tunnel[:channel].close if tunnel[:channel]
    if tunnel[:thread]
      tunnel[:thread].kill
      tunnel[:thread].join
    end
  end
end
=end

def apt_cmd(session,shcmd,aptcmd,aptopts,params='')
	aptproxy = nil
	case $mode
		when :KAVLAN
			aptproxy = 'Acquire::http::Proxy=\"http://localhost:3128\"'
		when :KVM
			aptproxy = ''
		else
			msg('Unknown mode',MSG_ERROR,true)
	end

  optname = Proc.new { |v|
      if v.size > 1
        "--#{v}"
      else
        "-#{v}"
      end
  }

  if aptopts.is_a?(Hash)
    aptopts['o'] = [aptproxy] if aptproxy and !aptproxy.empty?
    tmpopts = []
    aptopts.each do |k,v|

      if v.is_a?(String)
        tmpopts << "#{optname.call(k)} #{v}"
      elsif v.is_a?(Array)
        v.each { |o| tmpopts << "#{optname.call(k)} #{o}" }
      elsif v == nil
        tmpopts << k
      end
    end
    aptopts = tmpopts.join(' ')
  elsif aptopts.is_a?(Array)
    aptopts = aptopts.collect{|v| optname.call(v)}.join(' ')
    aptopts += " #{optname.call('o')} #{aptproxy}" if aptproxy and !aptproxy.empty?
  end
  params = params.join(' ') if params.is_a?(Array)

  sexec(session,"#{shcmd} #{aptcmd} #{aptopts} #{params}")
end

def apt_update(session)
  apt_cmd(session,'apt-get','update',['q'])
end

def apt_install(session,packages)
  apt_cmd(session,'apt-get','install',['q','y','force-yes','allow-unauthenticated'],packages)
end

def apt_remove(session,packages)
  apt_cmd(session,'apt-get','remove',['q','y','force-yes','purge'],packages)
end

def get_open_port()
  tmp=`netstat -l -n`
  usedports=[]
  tmp.each do |line|
    if line =~ /^\w+\s+\d+\s+\d+\s+.+:([-_\.\w]+)\s+.+:.+\s+\w*$/
      usedports << Regexp.last_match(1) unless usedports.include?(Regexp.last_match(1))
    end
  end

  begin
    randport = rand(2**16-2**10-1) + 2**10
  end while usedports.include?(randport)
  randport
end

def scp(dsthost,srcfile,dstfile)
	case $mode
		when :KAVLAN
			randport=get_open_port()
			cmd="ssh #{SSH_OPTIONS} -N -L #{randport}:#{dsthost}:22 -i #{$sshkeyfile} #{ENV['USER']}@#{getgw()} &>/dev/null & echo $!"
			msg(cmd) if $debug
			pid=`#{cmd}`
			#pid=`ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -N -L #{randport}:#{dsthost}:22 #{ENV['USER']}@#{getgw()} &>/dev/null & echo $!`

			time_start = Time.now
			begin
				tmp = `lsof -i4 | grep LISTEN | grep localhost:#{randport}`
				sleep(0.1)
				msg("SSH tunnel creation on localhost:#{randport} failed",MSG_ERROR,true) \
					if Time.now - time_start > 4
			end while !tmp or tmp.empty?

			cmd="scp -P #{randport} -r #{SSH_OPTIONS} -i #{$sshkeyfile} #{srcfile} root@localhost:#{dstfile} 2>&1 | grep -v 'Warning: Permanently added'"
			msg(cmd) if $debug
			`#{cmd}`
			`kill #{pid}`
		
		when :KVM
			cmd="scp -r -i #{$sshkeyfile} #{SSH_OPTIONS} #{srcfile} root@#{dsthost}:#{dstfile} 2>&1 | grep -v 'Warning: Permanently added'"
			msg(cmd) if $debug
			`#{cmd}`
		else
	end
end

def kadeploy_update(session,mountpath)
  # Check if debian package is installed
  tmp = sexec(session,'dpkg -s kadeploy-common')
  msg('dpkg error',MSG_ERROR,true) if !tmp or tmp.empty?
	tmp.each do |line|
		if line =~ /^Status: .* ([^ ]+)$/
			unless Regexp.last_match(1) == 'installed'
				msg("debian package 'kadeploy-common' is not installed",MSG_ERROR,true)
			end
		end
	end
  
  $update_paths.each do |key,localpath|
		next if key == UPDATE_DIR_VAR
		rlocalpath = File.join(mountpath,localpath)
    msg("Updating '#{key}' files",MSG_INFO)
    remotepaths = sexec(session,"dpkg -L kadeploy-common | grep '#{UPDATE_PATH_CHECK[key]}$'")
		remotepaths = [remotepaths] if remotepaths.is_a?(String)
    msg("file '#{UPDATE_PATH_CHECK[key]}' not found in kadeploy-common package",MSG_ERROR,true) if !tmp or tmp.empty?
		remotepaths.each do |remotepath|
			remotepath=remotepath.split(UPDATE_PATH_CHECK[key])[0]
			puts remotepath
			# Check nfs paths
			tmpcheck = sexec(session,"ls -a #{rlocalpath}",nil,false,false)
			msg("file '#{rlocalpath}' not found",MSG_ERROR,true) if !tmpcheck or tmpcheck.empty?
			
			localentries = Dir.entries(File.join($update_paths[UPDATE_DIR_VAR],localpath))
			localentries.delete('.')
			localentries.delete('..')
			localentries.each do |localentry|
				unless $update_paths.values.include?(File.join(localpath,localentry))
					sexec(session,"rm -Rf #{File.join(remotepath,localentry)}",nil,true)
					sexec(session,"ln -s #{File.join(rlocalpath,localentry)} #{remotepath}",nil,true)
					sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{File.join(remotepath,localentry)}") 
				end
      end
    end
  end
end

def tempfile(content)
  tmp = Tempfile.new(__FILE__)
  tmp.write(content)
  tmp.close

  yield(tmp.path)

  tmp.unlink 
end

def http_tunnel(host,session)
	case $mode
		when :KAVLAN
			msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
			ssh_tunnel_create(session,HTTP_PROXY_PORT,HTTP_PROXY_ADDR)

			yield

			msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
			ssh_tunnel_destroy(session,3128,getnode(host[:basename]))
		when :KVM
			msg('Creating HTTP proxy SSH tunnel',MSG_INFO)
			tmp = sexec(session,'route -n')
			msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
			gateway = nil
			iface = nil
			routed=false
			tmp.each do |line|
				if line =~ /^(\S+)\s+0\.0\.0\.0\s+\S+\s+.+$/ 
					routed = true if $network[:ipaddr].include?(Regexp.last_match(1))
				elsif line =~ /^0\.0\.0\.0\s+(\S+)\s+.+\s+(\S+)\s*$/ 
					gateway = Regexp.last_match(1)
					iface = Regexp.last_match(2)
					break
				end
			end
			sexec(session,"route add -host #{$network[:gateway]} dev #{$netiface}") unless routed
			sexec(session,'route del default') if gateway
			sexec(session,"route add default gw #{$network[:gateway]}")

			yield

			msg('Destroying HTTP proxy SSH tunnel',MSG_INFO)
			sexec(session,'route del default')
			sexec(session,"route add default gw #{gateway} dev #{iface}") if gateway
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
end

def set_default_route(session)
	if $mode == :KVM
		tmp = sexec(session,'route -n')
		msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
		gateway = false
		routed = false
		tmp.each do |line|
			if line =~ /^\S+\s+0\.0\.0\.0\s+\S+\s+.+$/ 
				routed = true 
			elsif line =~ /^0\.0\.0\.0\s+\S+\s+.+\s+\S+\s*$/ 
				gateway = true
			end
		end
		sexec(session,"route add -host #{KVM_GATEWAY} dev #{$netiface}") unless routed
		sexec(session,"route add default gw #{KVM_GATEWAY} dev #{$netiface}") unless gateway
	end
end

def kadeploy_tunnel(host,session)
	case $mode
		when :KAVLAN
			msg('Creating tunnel to kadeploy repository',MSG_INFO)
			sexec(session,"sed -i -e '/^.*#{DEB_REPOSITORY.gsub('/','\/')}.*$/d' /etc/apt/sources.list")
			sexec(session,"echo 'deb #{DEB_REPOSITORY} / ' >> /etc/apt/sources.list")
	
			http_tunnel(host,session) do
				yield
			end
			msg('Destroying tunnel to kadeploy repository',MSG_INFO)
		when :KVM
			msg('Creating tunnel to kadeploy repository',MSG_INFO)
			randport=get_open_port()
  		uri = URI.parse(URI.decode(DEB_REPOSITORY))
			url = "#{uri.scheme}://#{getgw()}:#{randport}#{uri.path}"
			sexec(session,"sed -i -e '/^.*#{getgw()}.*$/d' /etc/apt/sources.list")
			sexec(session,"echo 'deb #{url} / ' >> /etc/apt/sources.list")

			cmd="ssh #{SSH_OPTIONS} -N -L #{getgw()}:#{randport}:#{uri.host}:80 -i #{$sshkeyfile} #{KVM_G5K_USER}@#{KVM_G5K_SITE} 0>/dev/null 1>/dev/null & echo $!"
			msg(cmd) if $debug
			pid=`#{cmd}`

			time_start = Time.now
			begin
				tmp = `lsof -i4 -n | grep LISTEN | grep #{getgw()}:#{randport}`
				sleep(0.1)
				msg("SSH tunnel creation on localhost:#{randport} failed",MSG_ERROR,true) \
					if Time.now - time_start > 4
			end while !tmp or tmp.empty?

			puts pid.to_s
			
			http_tunnel(host,session) do
				yield
			end

			msg('Destroying tunnel to kadeploy repository',MSG_INFO)			
			`kill #{pid}`
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
end

def select_type(hash,type)
  hash.select { |n,h| h[:type] == type }.collect { |v| v[1] }
end

options[:node_list]   = nil
options[:debpackages] = []
options[:gempackages] = []
options[:git]         = nil
options[:ssh_key]     = nil
options[:version]     = nil
options[:daemon_kadeploy] = nil
options[:resolv] 			= false
options[:update_file] = nil
$debug				        = false
$netiface 						= NET_ADMIN_IFACE

args = ARGV.dup

optparse = OptionParser.new(USAGE) do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
  		puts opts
  		exit
	end
	
	opts.on( '-f', '--node-list <nodelist_file>', 'Specify a file containing the list of the nodes to be installed' ) do |n|
  	options[:node_list] = n
	end
	
	opts.on( '-d', '--debug', 'Verbose display of every instruction sent' ) do
  	$debug = true
	end
	
	opts.on( '-k', '--ssh-key [<ssh_key_file>]', 'Specify the path of the ssh private key to use' ) do |k|
  	options[:ssh_key] = k
	end

	opts.on( '-K', '--kvm', 'Use KVM nodes instead of deployed ones in kavlan (default)' ) do |k|
		$mode = :KVM
	end
	
	opts.on( '-g', '--git [<git_hash|git_tag>]', "Specify a specific version to install from git repository (if not specified, taking the last revision). Some packages are installed on one of the nodes in order to build the debian package (See `apt-get build-dep kadeploy-server` + deb: #{})" ) do |n|
  	options[:git] = n || :git_last
	end

	opts.on( 'u', '--update <updatefile>', "Update kadeploy files (the YAML update file should contain the local path for keys {#{UPDATE_PATH_CHECK.keys * ','}} to be bind on kadeploy server)" ) do |u|
  	options[:update_file] = u
	end
	
	opts.on( '-p', '--debpackages <package1>,<package2>,<...>', Array, 'Specify additional debian packages to be installed on the frontend' ) do |p|
  	options[:debpackages] = p
	end

	opts.on( '-i', '--net-iface <name>', "Specify the default network interfaces to be used on nodes (default: #{NET_ADMIN_IFACE})" ) do |i|
  	$netiface = i
	end
	
	#opts.on( '-r', '--gempackages <package1>,<package2>,<...>', Array, 'Specify additional gem packages to be installed on frontend' ) do |p|
  	#options[:gempackages] = p
	#end

	opts.on( '-d', '--kadeploy-daemon <node_address>', 'Specify which node should be used as kadeploy daemon (default: first node)' ) do |d|
  	options[:daemon_kadeploy] = d || nil
	end

	opts.on( '-x', '--toggle-resolv', 'Toggle hostname resolution considering the current mode (default in KAVLAN mode: enabled, default in KVN mode: disabled)' ) do |d|
  	options[:resolv] = true
	end
end

$startt = Time::now

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  msg(e.to_s,MSG_ERROR,true)
end

if ARGV.size < 2
  msg(USAGE)
  exit 1
end

if options[:resolv]
	case $mode 
		when :KAVLAN
			options[:resolv] = false
		when :KVM
			options[:resolv] = true
		else
			msg('Unknown mode',MSG_ERROR,true)
	end
end

if options[:ssh_key]
  if File.exists?(options[:ssh_key])
    $sshkeyfile = options[:ssh_key]
  else
    msg("ssh key #{options[:ssh_key]} not found",MSG_ERR,true)
  end
else
  sshkeyfiles = SSH_KEYS.select { |keypath| File.exists?(keypath) }
  if sshkeyfiles.empty?
    msg("no ssh private key file found (specify one with -k)",MSG_ERROR,true)
  else
    $sshkeyfile = sshkeyfiles[0]
  end
end

$update_paths = {}
if options[:update_file]
  if File.exist?(options[:update_file])
    begin
      $update_paths = YAML.load_file(options[:update_file])
    rescue ArgumentError
      msg("Invalid YAML file '#{options[:update_file]}'",MSG_ERROR,true)
    end
    msg("Invalid YAML file '#{options[:update_file]}'",MSG_ERROR,true) \
      unless $update_paths

		$update_paths[UPDATE_DIR_VAR] = '.' unless $update_paths[UPDATE_DIR_VAR]

		$update_paths[UPDATE_DIR_VAR] = File.expand_path($update_paths[UPDATE_DIR_VAR])
		
    begin
    	msg("#{options[:update_file]}: invalid working directory '#{$update_paths[UPDATE_DIR_VAR]}'",MSG_ERROR,true) unless File.directory?($update_paths[UPDATE_DIR_VAR])
    rescue ArgumentError
    	msg("#{options[:update_file]}: invalid working directory '#{$update_paths[UPDATE_DIR_VAR]}'",MSG_ERROR,true) 
		end

    nb = 0
		updatepath = $update_paths[UPDATE_DIR_VAR]
    $update_paths.each do |key,path|
			$update_paths[key] = path
			#$update_paths[key] = File.expand_path(path)
			next if key == UPDATE_DIR_VAR
      begin
        msg("#{options[:update_file]}: file not found '#{path}'",MSG_ERROR,true) \
          unless File.exist?(File.join(updatepath,$update_paths[key]))

        if UPDATE_PATH_CHECK[key]
           nb +=1
        else
          $update_paths.delete(key)
          msg("#{options[:update_file]}: invalid key '#{key}'",MSG_WARNING)
        end
      rescue ArgumentError
        msg("#{options[:update_file]}: file not found '#{path}'",MSG_ERROR,true)
      end
    end
    msg("#{options[:update_file]}: missing key(s) [needed: {#{UPDATE_PATH_CHECK.keys * ','}}]",MSG_WARNING) \
      if nb != UPDATE_PATH_CHECK.keys.size
  else
    msg("update file '#{options[:update_file]}' not found",MSG_ERROR,true)
  end
end

msg("=== Globals",MSG_INFO)
msg("  mode: #{$mode.to_s}",MSG_INFO)
msg("  sshkeyfile: #{$sshkeyfile}",MSG_INFO)
msg("  updatefile: #{options[:update_file]}",MSG_INFO) if options[:update_file]

# Checking kernels directory
msg("=== Gathering kernels information",MSG_INFO)
msg("invalid directory '#{ARGV[0]}'",MSG_ERROR,true) unless File.directory?(ARGV[0])
deplkernelfiles = Dir.entries(ARGV[0])
deplkernelfiles.delete('.')
deplkernelfiles.delete('..')
vmlinuzfiles = deplkernelfiles.select{ |filename| filename.include?('vmlinuz') }
vmlinuzfiles.each do |vmlinuzfile|
  initrdfile = File.join(ARGV[0],vmlinuzfile.gsub(/vmlinuz/,'initrd'))
  unless File.exist?(initrdfile)
    msg("initrd file for '#{vmlinuzfile}' kernel not found, ignoring kernel",MSG_WARNING)
    next
  end
  name = vmlinuzfile.gsub(/vmlinuz/,'').gsub(/--/,'-')
  $deplkernels[name] = {
    :name => name,
    :vmlinuz => File.join(ARGV[0],vmlinuzfile),
    :initrd => initrdfile
  }
	msg("#{$deplkernels[name][:name]}:",MSG_INFO)
	msg("  vmlinuz: #{$deplkernels[name][:vmlinuz]}",MSG_INFO)
	msg("  initrd: #{$deplkernels[name][:initrd]}",MSG_INFO)
end

msg("no valid deploiement kernel found in #{ARGV[0]}",MSG_ERROR,true) if $deplkernels.empty?

# Checking envs directory
msg("=== Gathering environments information",MSG_INFO)
msg("invalid directory '#{ARGV[1]}'",MSG_ERROR,true) unless File.directory?(ARGV[1])
envfiles = Dir.entries(ARGV[1])
envfiles.delete('.')
envfiles.delete('..')

envfiles = envfiles.select { |env| File.file?(File.join(ARGV[1],env)) }

envfiles.each do |env|
	$kaenvs[env] = {}
	$kaenvs[env][:dscfile] = File.join(CFG_KADEPLOY_ENVS_DESC_PATH,File.basename(env))
	tmp = File.new(File.join(ARGV[1],env)).read
	tmp.each do |line|
		if line =~ /^\s*name\s*:\s*([^ ]+)\s*$/
			$kaenvs[env][:name] = Regexp.last_match(1).strip
		elsif line =~ /^\s*tarball\s*:\s*([^ |]+)\|\S+\s*$/
			$kaenvs[env][:tarball] = Regexp.last_match(1).strip
		elsif line =~ /^\s*postinstall\s*:\s*([^ |]+)\|([^ |]+)\|(.*)$/
			$kaenvs[env][:postinstall] = {}
			$kaenvs[env][:postinstall][:file] = Regexp.last_match(1).strip
			$kaenvs[env][:postinstall][:filetype] = Regexp.last_match(2).strip
			$kaenvs[env][:postinstall][:args] = Regexp.last_match(3).strip
		elsif line.strip != '###' and !line.strip.empty?
			$kaenvs[env][:desc] = [] unless $kaenvs[env][:desc]
			$kaenvs[env][:desc] << line
		end
	end
	msg("#{$kaenvs[env][:name]}:",MSG_INFO)
	if $kaenvs[env][:tarball] and File.exist?($kaenvs[env][:tarball])
		msg("  tarball: #{$kaenvs[env][:tarball]}",MSG_INFO)
	else
		msg("can't find env #{env} tarball '#{$kaenvs[env][:tarball]}'",MSG_WARNING)
		$kaenvs.delete(env)
	end
	if $kaenvs[env] and $kaenvs[env][:postinstall]
		if File.exist?($kaenvs[env][:postinstall][:file])
			msg("  postinstall: #{$kaenvs[env][:postinstall][:file]}",MSG_INFO) \
		else
			msg("can't find env #{env} postinstall '#{$kaenvs[env][:postinstall][:file]}'",MSG_WARNING)
			$kaenvs.delete(env)
		end
	end
end


# Checking node list
if options[:node_list]
	nodelist_file = options[:node_list]
elsif (ENV['GOOD_NODES'])
	nodelist_file = ENV['GOOD_NODES']
elsif (ENV['OAR_NODEFILE'])
	nodelist_file = ENV['OAR_NODEFILE']
else
  msg("nodelist parameter not set",MSG_ERROR,true)
end

begin
	File.open(nodelist_file, 'r') do |f|
	  f.each{ |line| $allnodes << line.strip unless $allnodes.include?(line.strip) }
	end
rescue Errno::ENOENT
	msg("File '#{nodelist_file}' not found",MSG_ERROR,true)
end

msg("nodelist parameter empty",MSG_ERROR,true) if $allnodes.empty?
$allnodes.sort!

deplnodes = $allnodes.dup

kaserver = options[:deamon_kadeploy] || $allnodes[0]

if deplnodes.include?(kaserver)
	deplnodes.delete(kaserver)
else
  tmp = deplnodes.select { |node| node =~ /^#{kaserver}/ }
 	if tmp.empty?
  	msg("Kadeploy daemon not present in <nodes_file>",MSG_WARNING)
  else
    msg("Kadeploy daemon '#{kaserver}' assumed to be '#{tmp[0]}' (which is present in <nodes_file>)",MSG_WARNING)
    kaserver = tmp[0]
    deplnodes.delete(kaserver)
  end
end

$kanodes[:kadeploy] = {}
$kanodes[:kadeploy][:name] = 'kadeploy'
$kanodes[:kadeploy][:basename] = kaserver
$kanodes[:kadeploy][:type] = :SERVER

# >>> TODO: Add options
$kanodes[:dns] = {}
$kanodes[:dns][:name] = 'dns'
$kanodes[:dns][:basename] = kaserver
$kanodes[:dns][:type] = :SERVER

deplnodes.delete($kanodes[:dns][:basename])
$kanodes[:tftp] = {}
$kanodes[:tftp][:name] = 'tftp'
$kanodes[:tftp][:basename] = kaserver
$kanodes[:tftp][:type] = :SERVER
deplnodes.delete($kanodes[:tftp][:basename])

$kanodes[:dhcp] = {}
$kanodes[:dhcp][:name] = 'dhcp'
$kanodes[:dhcp][:basename] = kaserver
$kanodes[:dhcp][:type] = :SERVER
deplnodes.delete($kanodes[:dhcp][:basename])

$kanodes[:sql] = {}
$kanodes[:sql][:name] = 'sql'
$kanodes[:sql][:basename] = kaserver
$kanodes[:sql][:type] = :SERVER
deplnodes.delete($kanodes[:sql][:basename])

$kanodes[:frontend] = {}
$kanodes[:frontend][:name] = 'frontend'
$kanodes[:frontend][:basename] = kaserver
$kanodes[:frontend][:type] = :SERVER
deplnodes.delete($kanodes[:frontend][:basename])


msg('deploy nodelist empty',MSG_WARNING) if deplnodes.empty?

# Naming deploiement nodes
tmp = 1
deplnodes.each do |node|
  name = "#{NODE_NAME_PREFIX}#{tmp}"
  $kanodes[:"#{name}"] = {}
  $kanodes[:"#{name}"][:name] = name
  $kanodes[:"#{name}"][:basename] = node.strip
  $kanodes[:"#{name}"][:type] = :NODE
  tmp += 1
end

$kanodes.values.collect! do |v|
  v[:fqdn] = "#{v[:name]}.#{DOMAIN}"
	tmp = nil
	begin
		addr = IPAddr.new(v[:basename])
		# if nodename is an IP address
		if addr.ipv4?
			v[:ipv4] = v[:basename]
		else
			msg("Using IPv6 address for node '#{v[:basename]}', which is currently not supported",MSG_ERROR,true)
		end
		tmp = v[:basename]
	rescue ArgumentError
		# else if nodename is domain name
		tmp = v[:basename].split('.')[0]
	end
  v[:basenodename] = tmp

  if g5k?
    cluster = tmp.split('-')[0]
  else
    cluster = 'default'
  end

  unless $clusters[cluster]
    $clusters[cluster] = {}
    $clusters[cluster][:basename] = cluster
    $clusters[cluster][:name] = "#{cluster}#{CLUSTER_NAME_SUFIX}"
    $clusters[cluster][:nodes] = []
  end
  $clusters[cluster][:nodes] << v
  v[:cluster] = $clusters[cluster]
end

msg("=== Gathering cluster#{$clusters.size > 1 ? 's' : ''} information",MSG_INFO)
$clusters.values.collect! do |v|
  msg("#{v[:basename]}:",MSG_INFO)
  v[:kernel] = $deplkernels[$deplkernels.keys[0]]
  msg("  kernel: #{v[:kernel][:name]}",MSG_INFO)
  v[:drivers] = {}
  if g5k?
    tmp = nil
    begin
      tmp = JSON.parse(RestClient.get(G5K_API + "/grid5000/sites/#{$site.split('.')[0]}/clusters/#{v[:basename]}/nodes/#{v[:nodes][0][:basenodename]}"))
    rescue Exception
      msg('can\'t gather g5k api information',MSG_WARNING)
    end
    unless !tmp or tmp.empty?
      v[:drivers][:network] = tmp['network_adapters'].select do |na|
        na['device'] == $netiface
      end[0]['driver']
      v[:drivers][:disk] = tmp['storage_devices'][0]['driver']
    end
    tmpfile = File.join(G5K_POSTINSTALLS_PATH,"preinstall-#{v[:basename]}.tgz")
    if File.exist?(tmpfile)
      v[:postinstall] = tmpfile
    else
      msg("cluster #{v[:basename]} preinstall file not found in '#{G5K_POSTINSTALLS_PATH}'",MSG_WARNING)
    end
  end
  v[:drivers][:network] = DEFAULT_NET_DRIVER unless v[:drivers][:network] 
  v[:drivers][:disk] = DEFAULT_DISK_DRIVER unless v[:drivers][:disk] 

  msg("  net driver: #{v[:drivers][:network]}",MSG_INFO)
  msg("  disk driver: #{v[:drivers][:disk]}",MSG_INFO)
end


case $mode
	when :KAVLAN
		$kavlan_id = `kavlan --show-vlan-id`
		if $?.success? and !$kavlan_id.empty?
			begin 
				Integer($kavlan_id)
			rescue ArgumentError
				msg("kavlan not set",MSG_ERROR,true)
			else
				$kavlan_id = $kavlan_id.to_i
			end
		else
			msg("kavlan not set",MSG_ERROR,true)
		end

		# Disabling DHCP in kavlan
		`kavlan --disable-dhcp`
	when :KVM
	else
		msg('Unknown mode',MSG_ERROR,true)
end



Net::SSH.start(getgw(), ENV['USER'], :keys => $sshkeyfile) do |gwsession|
sshgw = Net::SSH::Gateway.new(getgw(), ENV['USER'], :keys => $sshkeyfile)

begin
  pubkey = File.open("#{$sshkeyfile}.pub",'r').read
rescue Errno::ENOENT
  msg("user public key file '#{$sshkeyfile}.pub' not found",MSG_WARNING)
else
  tmp = sexec(gwsession,"grep '#{pubkey}' ~#{ENV['USER']}/.ssh/authorized_keys; true;")[0]
   sexec(gwsession,"echo '#{pubkey}' >> ~#{ENV['USER']}/.ssh/authorized_keys") if !tmp or tmp.empty?
end

server=$kanodes[:dns]
servername=getnode(server[:basename])
msg('=== Gathering network information',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

  msg('Getting network information',MSG_INFO)
	set_default_route(session) if $mode == :KVM
  tmp = sexec(session,'route -n')
  msg('can\'t get route informations',MSG_ERRO,true) if !tmp or tmp.empty?
  defaultiface = nil
  tmp.each do |line|
    if line =~ /^(\S+)\s+0\.0\.0\.0\s+(\S+)\s+.+$/ 
      $network[:ipv4] = Regexp.last_match(1)
      $network[:mask] = Regexp.last_match(2)
      $network[:ipaddr] = IPAddr.new("#{$network[:ipv4]}/#{$network[:mask]}")
      $network[:broadcast] = ($network[:ipaddr] | (~$network[:ipaddr].instance_variable_get(:@mask_addr) & IPAddr::IN4MASK)).to_s
    elsif line =~ /^0\.0\.0\.0\s+(\S+)\s+.+\s+(\S+)\s*$/ 
      $network[:gateway] = Regexp.last_match(1)
      defaultiface = Regexp.last_match(2)
    end
  end

  if $network.empty?
    msg('unable to gather network information',MSG_ERROR,true)
  else
    msg('Network config:',MSG_INFO)
    msg("  addresses: #{$network[:ipv4]}/#{$network[:mask]}",MSG_INFO)
    msg("  gateway: #{$network[:gateway]}",MSG_INFO)
    msg("  broadcast: #{$network[:broadcast]}",MSG_INFO)
  end
  msg('can\'t find default network iface',MSG_ERROR,true) if !defaultiface or defaultiface.empty?
  

	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Getting nodes IPv4/MAC addresses',MSG_INFO)
		apt_install(session,'syslinux')
		$kanodes.values.each do |node|
			if node == :dns or node[:basename] == $kanodes[:dns][:basename]
				tmp = sexec(session,"ifconfig #{defaultiface}")
				msg('can\'t ifconfig default network iface',MSG_ERROR,true) if !tmp or tmp.empty?
				tmp.each do |line|
					if line.include?('HWaddr')
						node[:mac] = line.split('HWaddr')[1].strip.split[0]
					elsif line.include?('inet addr:')
						node[:ipv4] = line.split('inet addr:')[1].strip.split[0]
					end
				end
			else
				tmp = sexec(session,"gethostip -d #{getnode(node[:basename])}")[0]
				msg("can't get '#{node[:basename]}' IPv4 address",MSG_ERROR,true) if !tmp or tmp.empty?
				node[:ipv4] = tmp

				tmp = sexec(session,"ping -c 1 #{node[:ipv4]} &>/dev/null; arp -n | grep #{node[:ipv4]}")[0]
				msg("can't resolv '#{node[:basename]}' MAC address",MSG_ERROR,true) if !tmp or tmp.empty?
				node[:mac] = tmp.split[2].chomp
			end

			msg("can\'t collect IPv4/MAC on #{node[:basename]}",MSG_ERROR,true) \
				if !node[:mac] or !node[:ipv4] or node[:mac].empty? or node[:ipv4].empty?
		end

		msg('Removing configuration related packages',MSG_INFO)
		apt_remove(session,'syslinux')
	end
end
msg("Disconnected from #{server[:basename]}",MSG_INFO)
msg("",MSG_INFO)

server=$kanodes[:dns]
servername=getnode(server[:basename])
msg('=== Setting up DNS server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)

	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing DNS server',MSG_INFO)
		apt_install(session,'bind9')


		msg('Configuring DNS server',MSG_INFO)
		

		tempfile(cfg_dns_master()) {|path| scp(servername,path,cfg_bind_master_file())}
		sexec(session,"chown bind #{cfg_bind_master_file()}")

		tempfile(cfg_dns_reverse()) {|path| scp(servername,path,cfg_bind_reverse_file())}
		sexec(session,"chown bind #{cfg_bind_reverse_file()}")

=begin
		tmp = sexec(session,"grep '^nameserver' #{CFG_RESOLVCONF_FILE}")[0]
		if !tmp or tmp.empty?
			tmp = ''
			msg('no nameserver in resolv.conf file',MSG_WARNING)
		else
			tmp = tmp.split[1]
		end
=end
		# Assume that default DNS server is the network gateway
		tmp = $network[:gateway]
		tempfile(cfg_bind((tmp != $kanodes[:dns][:ipv4] ? tmp : ''))) do |path|
			scp(servername,path,CFG_BIND_NAMED_FILE)
		end
		sexec(session,"chown bind #{CFG_BIND_NAMED_FILE}")

		sexec(session,'service bind9 restart')

		msg('Updating resolv.conf files',MSG_INFO)
		tempfile(cfg_resolvconf()) {|path| scp(servername,path,CFG_RESOLVCONF_FILE)}

		excls = []
		excls << $kanodes[:dns][:ipv4]
		select_type($kanodes,:SERVER).each do |node|
			unless excls.include?(node[:ipv4])
				sexec(session,"scp -r #{SSH_OPTIONS} #{CFG_RESOLVCONF_FILE} root@#{node[:ipv4]}:#{CFG_RESOLVCONF_FILE}")
				excls << node[:ipv4]
			end
		end
	end
end
msg("Disconnected from #{server[:basename]}",MSG_INFO)
msg("",MSG_INFO)


server=$kanodes[:tftp]
servername=getnode(server[:basename])
msg('=== Setting up TFTP server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)
  
	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing TFTP server',MSG_INFO)
		apt_install(session,'debconf-utils')
		sexec(session,"rm -Rf #{CFG_TFTP_PATH}")
		sexec(session,"mkdir -p #{CFG_TFTP_PATH}")
		sexec(session,"echo 'tftpd-hpa tftpd-hpa/directory string #{CFG_TFTP_PATH}' | debconf-set-selections")
		sexec(session,"echo 'tftpd-hpa tftpd-hpa/username string #{CFG_TFTP_USER}' | debconf-set-selections")
		apt_install(session,'tftpd-hpa')

		msg('Configuring TFTP server',MSG_INFO)
		tempfile(cfg_tftp()) {|path| scp(servername,path,CFG_TFTP_CONF_FILE)}
		sexec(session,'service tftpd-hpa restart')

		msg('Installing bootfiles',MSG_INFO)
		apt_install(session,'syslinux-common')
		CFG_PXE_BOOTFILES.each do |bootfile|
			tmp = sexec(session,"dpkg -L syslinux-common | grep '^.*/#{bootfile}$'",false,false)
			msg("mandatory bootfile '#{bootfile}' not found in syslinux-common package",
				MSG_ERROR,true) if !tmp or tmp.empty? or !tmp[0] or tmp[0].empty?
			sexec(session,"ln -f #{tmp[0]} #{CFG_TFTP_PATH}")
		end

		msg('Installing deploiement kernels',MSG_INFO)
		sexec(session,"mkdir -p #{CFG_PXE_KERNELS_PATH}")
		$deplkernels.each do |name,kernel|
			msg("  Installing kernel #{name}",MSG_INFO)
			scp(servername,kernel[:vmlinuz],CFG_PXE_KERNELS_PATH)
			scp(servername,kernel[:initrd],CFG_PXE_KERNELS_PATH)
		end

		msg('Creating pxelinux configs',MSG_INFO)
		sexec(session,"mkdir -p #{CFG_PXE_CONFIG_PATH}")
		#apt_install(session,'syslinux')
		tempfile(cfg_pxe()) do |path|
			select_type($kanodes,:NODE).each do |node|
				#tmp = sexec(session,"gethostip -x #{node[:fqdn]}")[0]
				#msg("gethostip failed for '#{node[:fqdn]}', aborting",MSG_ERROR,true) \
				#  if !tmp or tmp.empty?
				tmp = IPAddr.new(node[:ipv4]).instance_variable_get(:@addr).to_s(16).upcase
				scp(servername,path,File.join(CFG_PXE_CONFIG_PATH,tmp))
			end
			scp(servername,path,File.join(CFG_PXE_CONFIG_PATH,'default'))
		end

		sexec(session,"chown #{CFG_TFTP_USER}:#{CFG_TFTP_USER} -R #{CFG_TFTP_PATH}")
		sexec(session,"chmod -R 755 #{CFG_TFTP_PATH}")

		msg('Removing configuration related packages',MSG_INFO)
		apt_remove(session,['debconf-utils'])
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)


server=$kanodes[:dhcp]
servername=getnode(server[:basename])
msg('=== Setting up DHCP server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)
  
	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing DHCP server',MSG_INFO)
		apt_install(session,'isc-dhcp-server')

		msg('Configuring DHCP server',MSG_INFO)
		tempfile(cfg_dhcp()) {|path| scp(servername,path,CFG_DHCP_CONF_FILE)}
		sexec(session,'service isc-dhcp-server restart')

		msg('Reloading network interfaces',MSG_INFO)
		sexec(session,'service networking restart &>/dev/null')
		excls = []
		excls << $kanodes[:dhcp][:ipv4]
		Net::SSH::Multi.start do |bcastsession|
			bcastsession.via getgw(), ENV['USER']
			select_type($kanodes,:SERVER).each do |node|
				unless excls.include?(node[:ipv4])
					bcastsession.use "root@#{node[:ipv4]}"
					excls << node[:ipv4]
				end
			end
			bcastsession.exec('service networking restart &>/dev/null')
		end
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)


server=$kanodes[:sql]
servername=getnode(server[:basename])
msg('=== Setting up SQL server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)
  
	http_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing mySQL server',MSG_INFO)
		apt_install(session,'debconf-utils')
		sexec(session,"echo 'mysql-server-#{CFG_MYSQL_VERSION} mysql-server/root_password password #{CFG_SQL_PASS_ROOT}' | debconf-set-selections")
		sexec(session,"echo 'mysql-server-#{CFG_MYSQL_VERSION} mysql-server/root_password_again password #{CFG_SQL_PASS_ROOT}' | debconf-set-selections")
		apt_install(session,'mysql-server')

		msg('Configuring mySQL server',MSG_INFO)
		#sexec("cat #{CFG_MYSQL_CONF_FILE} | sed -e '/bind-address/d' > #{tmp}; mv -f #{tmp} #{CFG_MYSQL_CONF_FILE}")
		tempfile(cfg_mysql()) {|path| scp(servername,path,CFG_MYSQL_CONF_FILE)}
		sexec(session,'service mysql restart')
		
		msg('Creating Kadeploy database',MSG_INFO)
		tmp = sexec(session,'tempfile')[0]
		msg('can\'t get temporary file',MSG_ERROR,true) if !tmp or tmp.empty?
		tempfile(cfg_sql()) {|path| scp(servername,path,tmp)}
		sexec(session,"mysql --user=root --password=#{CFG_SQL_PASS_ROOT} < #{tmp}")
		sexec(session,"rm #{tmp}")

		msg('Removing configuration related packages',MSG_INFO)
		apt_remove(session,'debconf-utils')
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)

server=$kanodes[:kadeploy]
servername=getnode(server[:basename])
msg('=== Setting up Kadeploy server',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)
  
	kadeploy_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Creating Kadeploy directories',MSG_INFO)
		sexec(session,"touch #{CFG_KADEPLOY_LOGFILE}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_LOGFILE}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_CACHE_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_CACHE_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_VAR_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_VAR_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_HOSTNAMES_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_DESC_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_DESC_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")
		sexec(session,"mkdir -p #{CFG_KADEPLOY_PREINSTALLS_PATH}")
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_PREINSTALLS_PATH}")

		msg('Copying clusters postinstall files',MSG_INFO)
		$clusters.values.each do |cluster|
			postinstallpath = cfg_kadeploy_specific_conf_postinstall_path(cluster)
			if postinstallpath
				scp(servername,cluster[:postinstall],postinstallpath)
				sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{postinstallpath}")
			end
		end

		msg('Copying and configuring environments',MSG_INFO)
		$kaenvs.values.each do |env|
			msg("  #{env[:name]} config",MSG_INFO)
			scp(servername,env[:tarball],File.join(CFG_KADEPLOY_ENVS_IMAGES_PATH,File.basename(env[:tarball])))
			scp(servername,env[:postinstall][:file],File.join(CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH,File.basename(env[:postinstall][:file]))) if env[:postinstall]
			tempfile(cfg_environment_desc(env)) do |path|
				scp(servername,path,env[:dscfile])
			end
		end
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_IMAGES_PATH}")
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_DESC_PATH}")
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_ENVS_INSTALLSCRIPTS_PATH}")

		msg('Installing Kadeploy server/client',MSG_INFO)
		apt_install(session,['kadeploy-server','kadeploy-client'])

		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_SSHKEY_PATH}")

		if options[:update_file]
			msg('Installing remote kadeploy files',MSG_INFO)
			msg('Installing sshfs',MSG_INFO)
			apt_install(session,'fuse-utils')
			
			msg("Creating local permanent tunnel to #{}:22 on localhost:#{UPDATE_FORWARD_PORT}",MSG_INFO)
			ssh_tunnel_create(session,22,$srchost,UPDATE_FORWARD_PORT)

			tmp = sexec(session,'mktemp -d')
			msg('can\'t create temp directory',MSG_ERROR,true) if !tmp or tmp.empty?
			msg("Mounting #{$update_paths[UPDATE_DIR_VAR]} in #{tmp} with sshfs",MSG_INFO)
			sexec(session,"sshfs #{SSH_OPTIONS} -o allow_other -p #{UPDATE_FORWARD_PORT} #{ENV['USER']}@localhost:#{$update_paths[UPDATE_DIR_VAR]} #{tmp}")

			kadeploy_update(session,tmp)
		end


		msg('Configuring Kadeploy server',MSG_INFO)
		tempfile(cfg_kadeploy_conf()) {|path| scp(servername,path,CFG_KADEPLOY_CONF_CONF_FILE)}
		tempfile(cfg_kadeploy_cmd()) {|path| scp(servername,path,CFG_KADEPLOY_CMD_CONF_FILE)}
		tempfile(cfg_kadeploy_clusters()) {|path| scp(servername,path,CFG_KADEPLOY_CLUSTERS_CONF_FILE)}
		tempfile(cfg_kadeploy_nodes()) {|path| scp(servername,path,CFG_KADEPLOY_NODES_CONF_FILE)}
		$clusters.values.each do |cluster|
			filepath = CFG_KADEPLOY_PARTITION_CONF_FILE_PREFIX+cluster[:name]
			tempfile(cfg_kadeploy_partition_file(cluster)) do |path|
				scp(servername,path,filepath)
			end
			sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{filepath}")

			filepath = CFG_KADEPLOY_SPECIFIC_CONF_FILE_PREFIX+cluster[:name]
			tempfile(cfg_kadeploy_specific_conf(cluster)) do |path|
				scp(servername,path,filepath)
			end
			sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{filepath}")
		end
		sexec(session,'service kadeploy3d restart')

		msg('Configuring Kadeploy client',MSG_INFO)
		tempfile(cfg_kadeploy_client()) do |path|
			scp(servername,path,CFG_KADEPLOY_CLIENT_CONF_FILE)
		end
		sexec(session,"chmod +r #{CFG_KADEPLOY_CLIENT_CONF_FILE}")

		# Ugly hack to be removed when the repository will be updated
		msg('Installing ruby',MSG_INFO)
		apt_install(session,'ruby')


		msg('Adding environments',MSG_INFO)
		$kaenvs.values.each do |env|
			sexec(session,"kaenv3 -u #{CFG_KADEPLOY_USER} -a #{env[:dscfile]}")
			msg("  #{env[:name]} ok",MSG_INFO)
		end

		msg('Set rights for frontend user',MSG_INFO)
		select_type($kanodes,:NODE).each do |node|
			sexec(session,"karights3 --overwrite-rights -a -m #{node[:fqdn]} -p #{CFG_KADEPLOY_DISK_DEVICE}#{CFG_KADEPLOY_PARTITION_DEPLOY_ID} -u #{CFG_FRONTEND_USER}");
		end

		msg('Setting up hostnames hack',MSG_INFO)
		scp(servername,$sshkeyfile,CFG_KADEPLOY_HOSTNAMES_SSHKEY)
		sexec(session,"chown #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_SSHKEY}")
		select_type($kanodes,:NODE).each do |node|
			sexec(session,"echo '#{node[:fqdn]}' > #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,node[:basename])}")
			sexec(session,"echo '#{node[:basename]}' > #{File.join(CFG_KADEPLOY_HOSTNAMES_PATH,node[:fqdn])}")
		end
		sexec(session,"chown -R #{CFG_KADEPLOY_USER}:#{CFG_KADEPLOY_USER} #{CFG_KADEPLOY_HOSTNAMES_PATH}")

		msg('Removing configuration related packages',MSG_INFO)
		#apt_remove(session,'kadeploy-client')
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)


server=$kanodes[:frontend]
servername=getnode(server[:basename])
msg('=== Setting up frontend',MSG_INFO)
sshgw.ssh(servername,'root') do |session|
  msg("Connected to #{server[:basename]}",MSG_INFO)
  
	kadeploy_tunnel(server,session) do
		msg('Updating debian packages list',MSG_INFO)
		apt_update(session)

		msg('Installing Kadeploy client',MSG_INFO)
		apt_install(session,'kadeploy-client')

		msg('Configuring Kadeploy client',MSG_INFO)
		tempfile(cfg_kadeploy_client()) do |path|
			scp(servername,path,CFG_KADEPLOY_CLIENT_CONF_FILE)
		end
		sexec(session,"chmod +r #{CFG_KADEPLOY_CLIENT_CONF_FILE}")
	end

	http_tunnel(server,session) do
		msg('Installing additional packages',MSG_INFO)
		apt_install(session,CFG_FRONTEND_PACKAGES)

		msg("Creating frontend user '#{CFG_FRONTEND_USER}'",MSG_INFO)
		sexec(session,"userdel --force --remove #{CFG_FRONTEND_USER}; true ;")
		sexec(session,"useradd --create-home --user-group --shell \"`which #{CFG_FRONTEND_SHELL}`\" --password '#{CFG_FRONTEND_USER_PASS}' #{CFG_FRONTEND_USER}")

		msg("Generating frontend user ssh key pair",MSG_INFO)
		sexec(session,"mkdir -p #{File.join("~#{CFG_FRONTEND_USER}",'.ssh')}")
		sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh')}")
		sexec(session,"ssh-keygen -f #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity')} -N '' -C '#{CFG_FRONTEND_USER}@#{server[:fqdn]}'")
		sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity')}")
		sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity.pub')}")
		
		msg("Copying user public key",MSG_INFO)
		begin
			pubkey = File.open("#{$sshkeyfile}.pub",'r').read
		rescue Errno::ENOENT
			msg("user public key file '#{$sshkeyfile}.pub' not found",MSG_WARNING)
		else
			sexec(session,"touch #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}")
			sexec(session,"chown #{CFG_FRONTEND_USER}:#{CFG_FRONTEND_USER} #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}")
			tmp = sexec(session,"grep '#{pubkey}' #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}; true;")[0]
			sexec(session,"echo '#{pubkey}' >> #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}") if !tmp or tmp.empty?
		end
		sexec(session,"cat #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','identity.pub')} >> #{File.join("~#{CFG_FRONTEND_USER}",'.ssh','authorized_keys')}")

		if options[:debpackages] and !options[:debpackages].empty?
			msg("Installing additional packages '#{options[:debpackages].join(',')}'",MSG_INFO)
			apt_install(session,options[:debpackages])
		end
	end
end
msg("Disconnected from #{server[:basename]}\n",MSG_INFO)
msg("",MSG_INFO)

end

msg("Installation done",MSG_INFO)
msg("Deploiement nodes:")
select_type($kanodes,:NODE).each do |node|
  msg("  #{node[:fqdn]} (#{node[:basename]})")
end
msg("Frontend: #{CFG_FRONTEND_USER}@#{getnode($kanodes[:frontend][:basename])}")

