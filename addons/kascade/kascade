#!/usr/bin/ruby


################################
## Rev 1:
##    -Little less verbose
##    -without -i take stay argument after parse to input
##    -put fountain.rb in temporary directory
##    -parse ssh command to get connexion parameter for kadeploy
##    -Add argument -m to set the master. (useful for integration next version )
##    -detection who_i_am is improved with ip search
## Rev 2: 
##    -Use the reporting server to decide of end.
##    -Add yaml file and different status to communicate with kadeploy
##    -Add aggressive mod
##    -Retries options
## rev 3:
##    -Integration of Taktuk launcher
##    -Integration of cluster shell launcher (in progress - test ssh parameter)
##    -Improve the node sort
## rev 4:
##    -Fusion of both script
##    -Taktuk become by default
## rev 5:
##    -Add protocol


require 'rubygems'
require 'optparse'
require 'shellwords'
require 'net/ssh'
require 'net/ssh/multi'
require 'socket'
require 'tempfile'
require 'securerandom'
require 'yaml'
require 'open3'
require 'pp'
# set old yameler
YAML::ENGINE.yamler = 'syck'

VERSION='v1.5'
KEYWORDS = {
    :HELLO => "HELLO-Kascade-#{VERSION}", #Hand shake to be sure
    :GET => 'GET', #ask data from offset
    :GET_PARTIAL => 'PGET', #ask number of data from offset
    :DATA => 'DATA', #Transfert the data
    :FORGET => 'FORGET', #the data asked is too old
    :QUIT => 'QUIT', #abord transfer
    :PASSED => 'PASSED', #inform all packet is passed useful in future version
    :REPORTING => 'REPORT',
    :FORGET_ERROR => 'FERROR', #?
    :END => 'END',
}

$log= Logger.new(STDERR)
$log.level=Logger::ERROR
beginning_time = Time.now


# Tools box
def fatal_error(message)
  $log.fatal message
  exit -1
end

class String
  def numberize
    Integer(self) rescue self
  end
end

def read_cmd(stream)
  line = stream.recv(100,Socket::MSG_WAITALL)
  raise 'unexpected close' if line==nil || line=='' || line.size!=100
  line.strip!
  $log.debug "command #{line} is received"
  line.split(' ')
end

def version_check(client)
  return true unless $config[:handshake]
  send_cmd(client,KEYWORDS[:HELLO])
  version=read_cmd(client)[0]
  return true if version == KEYWORDS[:HELLO]
  $log.error ("Bad protocol version : #{version}")
  false
end

def send_cmd(stream, *cmd)
  stream.send((cmd*' ').ljust(100), 0)
end

def kill_port(port)
  pid_to_kill = `lsof -t -i :#{port}`.strip
  if pid_to_kill!=''
    $log.info "kill pid #{pid_to_kill} because it using port #{port}"
    Process.kill('KILL', pid_to_kill.to_i)
    sleep(1)
  end
end

def get_nodes_list
  $config[:nodeList].map { |node| node.split(':')[0] }
end


def connect(line)
  $log.debug "Try to connect #{line}"
  host=line.split(':')
  host[1]=$config[:port] if host[1]==nil
  con=TCPSocket.new(host[0], host[1])
  $log.info "connection successful to #{line}"
  con
end

def connect_try(line)
  $config[:retries].downto(0) do |i|
    begin
      return connect(line)
    rescue Exception => e
      $log.debug e
      raise e if 0==i
      $log.warn("retry  #{i} on node #{line} : #{e.to_s}")
      sleep 1
    end
  end
end

def open_tcp_server(line = $config[:nodeList][$config[:who_i_am]])
  host=line.split(':')
  host[1]=$config[:port] if host[1]==nil
  kill_port(host[1]) if $config[:aggressive]
  $log.debug "Try to listen on #{host[1]}"
  ret = TCPServer.new(host[1])
  $log.info "listen #{host[1]}"
  ret
end

class Stack
  attr_reader :max_obj, :min_obj, :max_byte, :min_byte

  def initialize(size)
    @obj=Array.new(size)
    @min_obj=0
    @max_obj=-1
    @min_byte=0
    @max_byte=0
  end

  def push(obj)
    @max_obj+=1
    @max_byte+=obj.size
    i=@max_obj % @obj.size
    if @obj[i]!=nil
      @min_obj+=1
      @min_byte+=obj.size
    end
    @obj[i]=obj
  end

  def get(i)
    return nil if i>@max_obj || i<@min_obj
    @obj[i % @obj.size]
  end

  def get_all_limit(i, j)
    raise 'Nothing in stack' if i>@max_obj || i<@min_obj
    while i<=@max_obj && i<=j
      yield(@obj[i % @obj.size])
      i+=1
    end
  end

  def get_all_byte(i)
    raise 'Nothing in stack' if i>@max_byte || i<@min_byte
    get_all(i / @obj[0].size)
  end

  def get_all(i)
    raise 'Nothing in stack' if i>@max_obj || i<@min_obj
    while i<=@max_obj
      yield(@obj[i % @obj.size])
      i+=1
    end
  end
end

class Output
  attr_reader :queue

  def initialize(e)
    @stream=nil
    @threads=[]
  end

  def reader
    @queue=SizedQueue.new($config[:buffer_in_memory])
    @threads << Thread.new do
      begin
        while (buff=@queue.pop)!=nil
          @stream.write(buff)
        end
        @stream.close
      rescue Exception => e
        $log.debug(e)
      end
    end
  end

  def quit
    close
  end

  def close
    @stream.close
    #try
    @threads.each do |th|
      th.join
    end
  end
end

class StreamOutput < Output
  attr_reader :stream, :queue

  def initialize(cmd)
    super
    @cmd = cmd
  end

  def redirect(input, output)
    @threads<<Thread.new do
      until (line = input.gets).nil? do
        output.puts(line)
      end
    end
  end

  def init
    @stream, @out_stream, @err_stream, @wait_thr=Open3.popen3(@cmd)
    @threads<<@wait_thr
    redirect(@out_stream, $stdout)
    redirect(@err_stream, $stderr)
    reader
  end

  def quit
    Process.kill('INT', @wait_thr.pid)
    super
  end

  def arg
    "-O #{@cmd}"
  end
end

class FileOutput < Output
  attr_reader :stream, :queue

  def initialize(file_name=$stdout)
    @file_name=file_name
    super
  end

  def init
    if @file_name.is_a?(String)
      @stream=File.open(@file_name, 'w')
    else
      @stream=@file_name
    end
    reader
  end

  def close
    @stream.close
  end

  def quit
    close
    #rm file ?
  end

  def arg
    "-o #{@file_name}"
  end
end

# REPORT SERVER
class Report
  attr_reader :errors

  def initialize
    @errors={}
  end

  def receive_report(binary)
    @errors.merge!(YAML.load(binary))
  end

  def add_error(host, error)
    @errors[host]=error
  end

  def send_report_master
    $log.info 'I am the last and i send report to master'
    client = connect($config[:master])
    send_reporting(client)
    client.close
  end

  def send_reporting(stream)
    data=errors.to_yaml
    send_cmd(stream,KEYWORDS[:REPORTING],data.size)
    stream.write(data)
    $log.debug 'report sent'
  end

  def write_yaml_file(file_name, object)
    begin
      file=File.open(file_name, 'w')
      file.puts object.to_yaml
      file.close
    rescue => e
      $log.error "error during open file #{file_name} #{e.to_s}"
    end
  end

  def log_report(head, table)
    if $log.info?
      table.each do |node, error|
        $log.info "[#{head}] #{node}#{error==nil ? '' : ' - '+error.to_s}"
      end
    end
  end

  def make_report_files
    if $config[:ok_file]!=nil
      ok_node=$config[:nodeList].select { |n| @errors[n]==nil }
      log_report('node ok', ok_node)
      write_yaml_file($config[:ok_file], ok_node)
    end
    if $config[:ko_file]!=nil
      log_report('node ko', @errors)
      write_yaml_file($config[:ko_file], @errors)
    end
  end
end

class Deploy
  def start
    prefab
    Thread.new do
      begin
        deploy
      rescue Exception => e
        $log.error e
      end
    end
  end

  def prefab
    @secure_random = SecureRandom.hex
    @fountain_path = '/tmp/kascade' + @secure_random + 'fountain.rb'
    @nodes_path = '/tmp/kascade' + @secure_random + 'node_file'
    if $config[:sort]
      $config[:nodeList].sort_by! { |h| h.split('.').reverse.collect { |v| v.scan(/\d+|\p{Alpha}+|\W+/).map! { |n| n.numberize } }.flatten }
    end
    @nodes_ports = Shellwords.escape($config[:nodeList]*"\n")

    #Prepare commands
    @common_options=" -b #{$config[:buffer_size]} -n #{@nodes_path} -v #{$log.level} -R #{$config[:retries]} #{$config[:aggressive] ? '-A' : ''} -m #{$config[:master]} -D none"
    @command_fountain="ruby #{@fountain_path} #{$config[:output].arg} #{@common_options}"
  end

  def get_fountain_shell
    Shellwords.escape(File.read(__FILE__))
  end
end

class Ssh < Deploy
  def deploy
    $log.info 'Using ssh'
    ssh_options={}
    if $config[:ssh_command]!=nil
      flip=true
      #Split the ssh command string to obtain an array of argument. This split is double quote compliant
      ssh_args=$config[:ssh_command].split(/"/).collect { |t| flip=!flip; flip ? t : t.split(' ') }.flatten
      ssh_options_str={}
      OptionParser.new do |opts|
        opts.on('-o', '--option OPTION', 'puts option in ssh') do |v|
          opts=v.split('=')
          ssh_options_str[opts[0].downcase]=opts[1].numberize
        end
        opts.on('-p', '--port PORT', 'set port') do |v|
          ssh_options[:port]=v
        end
        opts.on('-l', '--login LOGIN', 'puts option in ssh') do |v|
          ssh_options[:user]=v
        end
        opts.on('-i', '--identification FILE', 'identification file') do |v|
          ssh_options[:keys]=v
        end
        opts.on('-q', '--quiet', 'Not used') {}
      end.parse(ssh_args)
      unless ssh_options_str.empty?
        tr=Net::SSH::Config.translate(ssh_options_str)
        ssh_options.merge!(tr)
      end
      $log.info "options for ssh #{ssh_options}"
    end


    # ALL FOUNTAINS
    Net::SSH::Multi.start(:on_error => :ignore) do |session|
      get_nodes_list.each { |node| session.use(node, ssh_options) }
      time = Time.now
      cmd = "echo #{get_fountain_shell} > #{@fountain_path} && echo #{@nodes_ports} > #{@nodes_path}"
      session.exec(cmd)
      session.loop
      time = Time.now - time
      $log.info "script forwarded in #{time}s"

      session.exec(@command_fountain)

      session.loop
    end
  end
end
class Taktuk < Deploy
  def deploy
    $log.info 'Using Taktuk'

    if $config[:nodeFile]==nil
      node_file=Tempfile.new('node_with_port')
      $config[:nodeList].each { |n| node_file.puts(n) }
      node_file.close
      node_file=node_file.path
    else
      node_file=$config[:nodeFile]
    end
    file = Tempfile.new('node_without_port')
    get_nodes_list.each { |node| file.puts node.split(':')[0] }
    file.close
    if $config[:ssh_command]!=nil
      ssh_opt="-c \"#{$config[:ssh_command]}\""
    else
      ssh_opt=''
    end
    cmd="taktuk #{$log.info? ? '' : '-o status=-'} #{ssh_opt} -f #{file.path} broadcast put [ #{__FILE__} ] [ #{@fountain_path} ], broadcast put [ #{node_file} ] [ #{@nodes_path} ], broadcast exec [ #{@command_fountain} ]"
    $log.info 'launching : '+cmd
    system(cmd)
  end

end

class Clush < Deploy
  def deploy
    $log.info 'Using ClusterShell'
    node_set=`nodeset -f #{get_nodes_list*' '}`.strip
    if $config[:ssh_command]!=nil
      ssh_opt="--option='#{$config[:ssh_command]}'"
    else
      ssh_opt=''
    end
    in_cmd=Shellwords.escape("echo #{get_fountain_shell} > #{@fountain_path} && echo #{@nodes_ports} > #{@nodes_path} && #{@command_fountain}")
    cmd="clush -w '#{node_set}' #{$log.info? ? '' : '-q'} #{ssh_opt} #{in_cmd}"
    #system(cmd)
    pid=fork { exec(cmd) }
    Process.wait(pid)
  end
end

class ReadException < Exception
  attr_reader :byte_readed

  def initialize(byte_readed)
    @byte_readed=byte_readed
  end
end
class ForgetException < Exception

end
class WriteException < Exception
  attr_reader :exception

  def initialize(exception)
    @exception=exception
  end
end

class FirstFountain
  attr_reader :report

  def initialize
    @index=0
    @passed=false
    @last_node=false
    @report=Report.new
    if $config[:input]==nil # from standard input
      $log.info 'using standard input'
      @input=nil
      read_input_thread
      @stack=Stack.new($config[:chunk_in_memory])
    else
      $log.info "using  '#{$config[:input]}'"
      @input=File.open($config[:input])
      @stack=nil
    end
    @chunk_size=$config[:buffer_size]*$config[:chunk_size]
    master_server
    start_sender
  end

  def wait_passed(output_stream)
    cmd=read_cmd(output_stream)
    if (cmd[0]!=KEYWORDS[:PASSED])
      raise "Bad Keyword #{cmd[0]}"
    end
  end
  def retries
    if @last_node
      yield nil,0
    else
      begin
        begin
          if @output_stream
            yield @output_stream,@byte_need_to_send
            return
          else
            @output_stream=connect_try($config[:nodeList][@index])
            #while true
              cmd=read_cmd(@output_stream)
              case cmd[0]
                when KEYWORDS[:GET]
                  @byte_need_to_send=cmd[1].to_i
                  begin
                    yield @output_stream,@byte_need_to_send
                  rescue ForgetException => e
                    $log.debug(e)
                  end
                  return
                when KEYWORDS[:PASSED]
                  $log.info('file passed')
                  @passed=true
                  @output_stream.close
                  return
                else
                  $log.debug "#{cmd[0]} instead GET or PASSED"
                  raise "Bad Keyword '#{cmd[0]}'"
              end
            #end
          end
        rescue ReadException => ex_read
          $log.debug(ex_read)
          raise ex_read
        rescue Exception => e
          $log.debug e
          @report.add_error($config[:nodeList][@index], e)
          @index+=1
          @retries=$config[:retries]
          @last_node=$config[:nodeList].size==@index
          @output_stream=nil
          $log.error("#{e.to_s}")
          $log.debug(e)
        end
      end while !@last_node && !@passed
    end
  end

  def start_sender
    retries do |output_stream,byte_need_to_send|
      if output_stream
        send_data(output_stream, byte_need_to_send)
        report.send_reporting(output_stream)
        wait_passed(output_stream)
      end
    end
    turnoff_master_server if @last_node
  end

  def read_input_thread
    @pop=SizedQueue.new($config[:chunk_in_memory]) #times chunk_size ?
    @in_th=Thread.new do
      begin
        until $stdin.eof? do
          @pop.push($stdin.read(@chunk_size))
        end
        @pop.push(nil)
      rescue Exception => e
        $log.error e
      end
    end
  end

  def send_chunk(output_stream, chunk)
    send_cmd(output_stream, KEYWORDS[:DATA], chunk.size)
    output_stream.send(chunk, 0)
    chunk.size
  end

  def send_data(output_stream, byte_from)
    if $config[:input].nil? # input stream
      cut=byte_from % @chunk_size
      i=byte_from/@chunk_size
      if @stack.min_obj>i
        send_cmd(KEYWORDS[:FORGET], min)
      else
        while @stack.max_obj>i # looking for in memory
          chunk=get(i)
          if cut>0
            chunk=chunk[cut: -1]
            cut=0
          end
          send_chunk(output_stream, chunk)
          i+=1
        end
        while (chunk=@pop.pop).nil? #read
          send_chunk(output_stream, chunk)
          @stack.push(chunk)
        end
      end
    else #File input
      input=@input
      size=input.size
      buffer_size=$config[:buffer_size]
      chunk_size=$config[:chunk_size]
      @input.seek(byte_from, IO::SEEK_SET)
      while size > 0
        data_size=[chunk_size, size].min
        send_cmd(output_stream, KEYWORDS[:DATA], data_size)
        size-=data_size
        while data_size > 0
          output_stream.send(input.read(buffer_size), 0)
          data_size -=buffer_size
        end
      end
    end
  end

  def send_data_master(output_stream, byte_from, byte_to)
    if $config[:input]
      input=File.open($config[:input])
      input.seek(byte_from, IO::SEEK_SET)
      data_size=[byte_to-byte_from, input.size-byte_from].min
      send_cmd(output_stream, KEYWORDS[:DATA], data_size)
      output_stream.send(input.read(data_size), 0)
      input.close
    else
      if byte_from<@stack.min_byte
        send_cmd(output_stream, KEYWORDS[:FORGET], @stack.min_byte)
      else
        data_size=[byte_to-byte_from, @stack.max_byte-byte_from].min
        send_cmd(output_stream, KEYWORDS[:DATA], data_size)
        #i=byte_from/@chunk_size
        while data_size>0
          #chunk=@stack.get(i)
          # if chunk>
          #i+=1
          raise 'not implemented yet'
        end
      end
    end
  end

  def turnoff_master_server
    @run_master_server=false
    @master_server.shutdown
    report.make_report_files
  end

  def master_server
    @run_master_server=true
    @master_server_thread=Thread.new do
      begin
        @master_server=open_tcp_server($config[:master])
        while @run_master_server
          Thread.start(@master_server.accept) do |client|
            begin
              $log.info("#{client.peeraddr(true)[2]} is connected in master")
              cmd=read_cmd(client)
              case cmd[0]
                when KEYWORDS[:GET_PARTIAL]
                  send_data_master(client, cmd[1].to_i, cmd[2].to_i)
                when KEYWORDS[:REPORTING]
                  report.receive_report(client.read(cmd[1].to_i))
                  turnoff_master_server
                else
                  $log.error("Reader has relieve unknown command #{cmd[0]}")
              end
            rescue Exception => ex
              $log.error(ex)
            end
            client.close
          end
        end
      rescue Exception => ex
        $log.error ex if @run_master_server
        $log.info 'master server was shunted down'
      end
    end
  end
  def join
    @master_server_thread.join
  end
end


class Fountain < FirstFountain
  def initialize
    @index=$config[:who_i_am]+1
    @last_node=$config[:nodeList].size-1==$config[:who_i_am]
    @server=open_tcp_server
    @bytes_readed=0
    @report=Report.new
    $config[:output].init
    start_receiver
  end

  def start_receiver
    stack=Stack.new($config[:buffer_in_memory])
    input_stream=@server.accept
    send_cmd(input_stream,KEYWORDS[:GET], stack.max_byte)

    begin
      begin
        cmd=read_cmd(input_stream)
        case cmd[0]
          when KEYWORDS[:DATA] #
            chunk_transmission(input_stream, stack, cmd[1].to_i)
          when KEYWORDS[:FORGET] # try to contact the master
            master=connect $config[:master]
            send_cmd(master, KEYWORDS[:GET_PARTIAL], @bytes_readed, answer[1]) #{@chunk_offset}\n")
            answer=read_cmd(master)
            case answer[0]
              when KEYWORDS[:FORGET] #You loose
                master.close
                @game_over=true
                break
              when KEYWORDS[:DATA]
                begin
                  chunk_transmission(master, stack, answer[1].to_i)
                  @chunk_read+=1
                  answer=read_cmd(master)
                end while answer[0]==KEYWORDS[:DATA]
              else
                $log.error("Master send unknown command #{answer[0]}")
            end
          when KEYWORDS[:QUIT]
            $log.info('quitting...')
            @report.add_error($config[:nodeList][$config[:who_i_am]], 'EXITED')
            $config[:QUIT]=1
            retries do |output_stream|
              output_stream.send_cmd(KEYWORDS[:QUIT])
            end
          when KEYWORDS[:REPORTING]
            report.receive_report(input_stream.read cmd[1].to_i)
            retries do |output_stream|
              if output_stream
                @report.send_reporting(output_stream)
                wait_passed(output_stream)
              else
                @report.send_report_master
              end
            end
            $log.info "Report #{@report.errors.size} element(s)"
            send_cmd(input_stream,KEYWORDS[:PASSED])
            $log.debug('Passed Send')
            break
          else
            $log.error("Reader has relieve unknown command #{cmd[0]}")
            break
        end
      rescue Exception => ex
        $log.debug ex
        input_stream.close
        input_stream=@server.accept
        send_cmd(input_stream,KEYWORDS[:GET], stack.max_byte)
      end
    end while true
  end

#try this
  def chunk_transmission(input_stream, stack, size)
    buffer_size=$config[:buffer_size]
    file=$config[:output].queue
    byte_remaining=size
    retries do |output_stream,from_byte|
      if from_byte < stack.min_byte
        send_cmd(output_stream, KEYWORDS[:FORGET], stack.min_byte)
        raise "forget #{from_byte} < #{stack.min_byte}"
      end
      if stack.max_byte > from_byte && output_stream
        send_cmd(output_stream, KEYWORDS[:DATA], stack.max_byte-from_byte)
        stack.get_all_byte(from_byte) do |buff|
          output_stream.send(buff, 0)
        end
      end
      send_cmd(output_stream, KEYWORDS[:DATA], size) if byte_remaining==size && output_stream
      while byte_remaining > 0
        read_needed=[buffer_size, byte_remaining].min
        buffer = input_stream.recv(read_needed, Socket::MSG_WAITALL)
        if buffer && buffer.size==read_needed
          byte_remaining-=buffer.size
          begin
            output_stream.send(buffer, 0) if output_stream
          rescue Exception => e #Write failure, ask new forwarder
            file.push(buffer)
            stack.push(buffer)
            raise e
          end
          file.push(buffer)
          stack.push(buffer)
        else #read failure wait new forwarder.
          raise ReadException.new(size-byte_remaining)
        end
      end
    end
  end

  def join

  end
end

# CONFIGURATION
$config = {
    :port => 10000,
    :buffer_size => 1024*64, #1460*64
    :input => nil,
    :ok_file => nil,
    :ko_file => nil,
    :master => nil,
    :ssh_command => nil,
    :deploy => Taktuk.new,
    :retries => 10,
    :output => FileOutput.new($stdout),
    :who_i_am => nil,
    :buffer_in_memory => 128,
    :chunk_size => 160
}


OptionParser.new do |opts|
  opts.banner = "Usage: ruby #{__FILE__} [options]"
  opts.separator ''
  opts.separator 'Specific options : '
  opts.on('-A', '--[no-]aggressive', 'kill process which use the listen port') { |v| $config[:aggressive] = v }
  opts.on('-b', '--buffer-size SIZE', "the number of byte which read and passed (default : #{$config[:buffer_size]}") { |v| $config[:buffer_size] = v.to_i }
  opts.on('-c', '--[no-]check-md5', 'check md5sum') { |v| $config[:check_md5] = v }
  opts.on('-C', '--chunk-size SIZE', "how much buffer readed before read next header (default : #{$config[:chunk_size]})")
  opts.on('-D', '--deploy [ssh,taktuk,clush]', [:ssh, :taktuk, :clush, :none], 'Choose deploy method. Ssh is default value') do |v|
    case v
      when :ssh
        $config[:deploy]=Ssh.new
      when :clush
        $config[:deploy]=Clush.new
      when :taktuk
        $config[:deploy]=Taktuk.new
      when :none
        $config[:deploy]=nil
      else
        raise "deploy type #{v} does not available"
    end
  end
  opts.on('-H', '--[no-]disable-handshake', 'disable the handshake') { |v| $config[:handshake]=!v }
  opts.on('-i', '--input FILE', 'input file') do |v|
    $config[:input] = v
    $config[:who_i_am]=-1
    fatal_error "file #{v} does not exist" unless File.exist?(v)
    $config[:filesize]=File.size(v)
  end
  opts.on('-k', '--ok FILE', 'list of node correctly deployed') { |v| $config[:ok_file] = v }
  opts.on('-K', '--ko FILE', 'list of node with error') { |v| $config[:ko_file] = v }
  opts.on('-m', '--master HOST', 'Specify the master hostname') { |v| $config[:master] = v }
  opts.on('-n', '--node-file FILE', 'node file') do |v|
    # READS NODE FILE
    $config[:nodeFile]=v
    begin
      $config[:nodeList] = File.readlines(v).map { |l| l.strip }
    rescue Exception => ex
      fatal_error "Error : could not open #{v} file: #{ex.to_s}"
    end
  end
  opts.on('-N', '--node n1[:p1],n2[:p2],...', Array, 'list of node') { |v| $config[:nodeList]=v }
  opts.on('-o', '--output [FILE]', 'output file') { |v| $config[:output] = FileOutput.new(v) }
  opts.on('-O', '--output-cmd [CMD]', 'output command') { |v| $config[:output] = StreamOutput.new(v) }
  opts.on('-p', '--port PORT', 'default port') { |v| $config[:port] = v }
  opts.on('-R', '--retry num', 'Set number retry attempts, by default this value is 10 and each retry is performed after 1s') { |v| $config[:retries] = v.to_i }
  opts.on('-s', '--[no-]sort', 'sort the node file') { |v| $config[:sort] = v }
  opts.on('-S', '--ssh-command SSH', 'parse ssh command') { |v| $config[:ssh_command] = v }
  opts.on('-u', '--number-of-chunk NB', 'Number of max chunk stored') { |v| $config[:chunk_in_memory]=v.to_i }
  opts.on('-v', '--verbose [warn,info,debug]', 'run verbosely') do |v|
    case v
      when 'warn'
        $log.level=Logger::WARN
      when 'debug'
        $log.level=Logger::DEBUG
      when 'info'
        $log.level=Logger::INFO
      else
        $log.level=v.to_i
    end
  end
  opts.on('-W', '--who-i-am NUM', 'number of node it is') { |v| $config[:who_i_am] = v.to_i }
  opts.separator ''
  opts.separator 'Common options :'
  opts.on_tail('-?', '--help', 'show this message') do
    puts opts
    exit
  end
end.parse!

if $config[:master]==nil
  $config[:master]=`hostname`.strip
end

if $config[:who_i_am].nil?
  my_list = $config[:nodeList].map { |l| l.split(':')[0] }
  who=my_list.index(Socket.gethostname)
  if who==nil
    host=ENV['HOST']
    who = my_list.index(host) if host!=nil
  end
  if who==nil
    ips=Socket.ip_address_list
    who=my_list.index { |ip| ips.index { |ip2| ip2.ip_address==ip } }
  end
  raise 'I don\'t know who i am !' if who==nil
  $config[:who_i_am]=who
end


#### --- MAIN
$config[:deploy].start if $config[:deploy]!=nil && $config[:who_i_am]==-1

time_before_fountain = Time.now

if $config[:who_i_am]==-1 # master
  $log.info 'I am the master'
  fountain=FirstFountain.new
else
  $log.info "I am number #{$config[:who_i_am]}"
  fountain=Fountain.new
end

$log.info 'fountain exited'
fountain.join
time_before_fountain = Time.now - time_before_fountain
total_time = Time.now - beginning_time
if $config[:who_i_am]==-1 && $log.info?
  $log.info "\tFILE\t\t:\t#{$config[:input]}"
  $log.info "\tSIZE\t\t:\t#{$config[:filesize]} bytes"
  $log.info "\tNODES\t\t:\t#{$config[:nodeList].size}"
  $log.info "\tTRANSFER TIME\t:\t#{time_before_fountain} seconds"
  $log.info "\tTOTAL TIME\t:\t#{total_time} seconds"
end
