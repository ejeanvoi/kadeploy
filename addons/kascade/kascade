#!/usr/bin/ruby

require 'rubygems'
require 'optparse'
require 'shellwords'
require 'net/ssh'
require 'net/ssh/multi'
require 'socket'
require 'tempfile'
require 'securerandom'
require 'yaml'

start = Time.now

options = {
  :port => 10000,
  :output => "/tmp/output",
  :buffersize => 1750*64, #1460*64
  :input=>nil,
  :okfile=>nil,
  :kofile=>nil,
  :master=>nil,
  :sshcommand=>nil
}

OptionParser.new do |opts|
  opts.banner = "Usage: ruby #{__FILE__} [options]"
  opts.separator ""
  opts.separator "Specific options : "
  opts.on("-i", "--input FILE", "input file") { |v| options[:input] = v }
  opts.on("-b", "--buffersize SIZE", "buffer sise") { |v| options[:buffersize] = v }
  opts.on("-c", "--check", "check the report")  { |v| options[:check] = v }
  opts.on("-C", "--[no-]checkmd5", "check md5sum") { |v| options[:checkmd5] = v }
  opts.on("-k", "--ok FILE", "list of node correctly deployed") { |v| options[:okfile] = v }
  opts.on("-K", "--ko FILE", "list of node with error") { |v| options[:kofile] = v }
  opts.on("-m", "--master HOST", "Specify the master hostname") { |v| options[:master] = v }
  opts.on("-n", "--nodefile FILE", "node file") { |v| options[:nodefile] = v }
  opts.on("-o", "--output [FILE]", "output file") { |v| options[:output] = v }
  opts.on("-O", "--outputcmd [CMD]", "output command") { |v| options[:outputcmd] = v }
  opts.on("-p", "--port PORT", "start port") { |v| options[:port] = v }
  opts.on("-s", "--[no-]sort", "sort the node file") { |v| options[:sort] = v }
  opts.on("-S", "--ssh-command SSH", "parse ssh command") { |v| options[:sshcommand] = v }
  opts.on("-v", "--[no-]verbose", "run verbosely") { |v| $Verbose = v }
  opts.separator ""
  opts.separator "Common options :"
  opts.on_tail("-h", "--help", "show this message") do
    puts opts
    exit
  end
end.parse!
if options[:input]==nil
  options[:input]=ARGV[0]
end
if options[:master]==nil
  options[:master]=`hostname`.strip
end

# GENERATES TEMP FILE
secureRandom = SecureRandom.hex
fountainPath = "/tmp/kascade" + secureRandom + "fountain.rb"
firstFountainPath = "/tmp/kascadef" + secureRandom + "fountain.rb"
nodesPath = "/tmp/kascade" + secureRandom + "nodefile"
reportPath = "/tmp/kascade" + secureRandom + "report"

# READS NODEFILE
begin
  nodes = File.readlines(options[:nodefile]).map{ |x| x.strip}
rescue
  raise "Error : specified nodefile does not exists"
end

if options[:sort]
  nodes2 = []
  nodes.each do |n|
    clusterAndNode, siteName = n.split(".")
    clusterName, nodeNumber = clusterAndNode.split("-")
    while nodeNumber && nodeNumber.size < 3
      nodeNumber.insert(0, "0")
    end
    if nodeNumber
      nodeNumber.insert(0, "-")
    else
      nodeNumber = ""
    end
    nodes2 << siteName + "." + clusterName + nodeNumber
  end
  nodes2.sort!
  nodes = []
  nodes2.each do |n|
    siteName, clusterAndNode = n.split(".")
    clusterName, nodeNumber = clusterAndNode.split("-")
    if nodeNumber
      nodeNumber = nodeNumber.to_i.to_s
      nodeNumber.insert(0, "-")
    else
      nodeNumber = ""
    end
    nodes << clusterName + nodeNumber + "." + siteName + ".grid5000.fr"
  end
end

i = 0
nodesPorts = nodes.map do |line| 
  port = options[:port].to_i + i + 1
  i += 1
  line = line.chomp + ":#{port}"
end
nodesPorts = nodesPorts.unshift("#{options[:master]}:#{options[:port]}").join("\n")
nodesPorts = Shellwords.escape(nodesPorts)


# FIRST FOUNTAIN
fountain = Shellwords.escape(File.read(__FILE__).split(/^# FOUNTAIN/)[1])
cmd = "echo #{fountain} > #{firstFountainPath}" 
system(cmd)
cmd = "echo #{nodesPorts} > #{nodesPath}"
system(cmd)

# REPORT SERVER
report = []
koNodes={}
report_thr = Thread.new {
  reportPiece = ""
  begin 
    server = TCPServer.new(options[:port])
        puts "[Reporting server]  launched"  if $Verbose
    while reportPiece != "end" do
      Thread.start(server.accept) do |reportSock|
        laddr=reportSock.peeraddr(true)[2]
        puts "[Reporting server] connected from #{laddr}"  if $Verbose
        reportPiece = reportSock.gets.strip
        puts "[Reporting server] report received from #{laddr}: #{reportPiece}" if $Verbose
        if reportPiece != "end"
    report << reportPiece
    parts = reportPiece.split(' - ')
    if parts.size > 1
      koNodes[parts[0]]=parts[1,parts.size]*" - "
    else
      koNodes[parts[0]]="Unknown Error"
    end
    reportSock.close
        else 
    reportSock.close
    server.shutdown
    break
        end
      end
    end
  rescue => e
    if (reportPiece == "end")
    puts "[Reporting server] closed"  if $Verbose
  else
    $stderr.puts e.to_s
  end
  
  end
}


# =================== Parse ssh options =================== 
ssh_options={}
if options[:sshcommand]!=nil
  class String
    def numberize
    Integer(self) rescue self
    end
  end
  flip=false
  sshargs=options[:sshcommand].split(/"/).collect{|t| flip!=flip; flip ? t : t.split(' ')}.flatten 
  ssh_options_str={}
  OptionParser.new do |opts|
    opts.on("-o", "--option OPTION", "puts option in ssh") do |v|
      opts=v.split("=")
      ssh_options_str[opts[0].downcase]=opts[1].numberize
    end
    opts.on("-p","--port PORT","set port")do |v|
      ssh_options[:port]=v
    end
    opts.on("-l","--login LOGIN", "puts option in ssh") do |v|
      ssh_options[:user]=v
    end
    opts.on("-i","--indentification FILE","identification file") do |v|
      ssh_options[:keys]=v
    end
    opts.on("-q","--quied","Not used") {|v|}
    
  end.parse(sshargs)
  if !ssh_options_str.empty?
    tr=Net::SSH::Config.translate(ssh_options_str)
    ssh_options.merge!(tr)
  end
  puts "options for ssh #{ssh_options}" if $Verbose
end


# ALL FOUNTAINS
verbose = $Verbose ? "--verbose" : "--no-verbose"
Net::SSH::Multi.start(:on_error => :ignore) do |session|
  nodes.each { |node| session.use(node,ssh_options) }
  time = Time.now
  cmd = "echo #{fountain} > #{fountainPath} && echo #{nodesPorts} > #{nodesPath}"
  session.exec(cmd)
  session.loop
  puts "HOST : " + Socket.gethostname if $Verbose
  time = Time.now - time
  puts "script forwarded in #{time}s" if $Verbose

  commonOptions=" -b #{options[:buffersize]} -s #{File.size(options[:input])} -n #{nodesPath} #{verbose} #{options[:agressive] ? '-A' : ''}"
  
  cmd = "ruby #{fountainPath} -o #{options[:output]} -O \"#{options[:outputcmd]}\""+commonOptions
  session.exec(cmd)
  start_thr = Thread.new { #firstfountain
    cmd = "ruby #{firstFountainPath} -i #{options[:input]}"+commonOptions
    time = Time.now
    system(cmd)
  }

  session.loop
  
  start_thr.join
  time = Time.now - time
  totalTime = Time.now - start
  if $Verbose
    puts "KASCADE :"
    puts "\tFILE\t\t:\t#{options[:input]}"
    puts "\tSIZE\t\t:\t#{File.size(options[:input])} bytes"
    puts "\tNODES\t\t:\t#{nodes.length}"
    puts "\tTRANSFER TIME\t:\t#{time} seconds"
    puts "\tTOTAL TIME\t:\t#{totalTime} seconds"
  end
  if !report.empty?
    report.uniq!
    puts "#{report.length} errors has been reported, creating a report file : " + reportPath
    reportFile = File.new(reportPath, "w")
    reportFile.write(report.join("\n"))
    reportFile.close
  end
  if options[:check]
    nodes.map { |node| node.chomp! }
    nodes.each do |node|
      if report.include?(node)
        puts node + "\t--\tNOT OK"
      else
        puts node + "\t--\tOK"
      end
    end
  end
  if options[:checkmd5]
    if options[:outputcmd]
      puts "Can't check MD5 Sum when output command is given"
    else
      ref = `md5sum #{options[:input]}`
      puts "\nReference MD5 Sum : #{ref}"
      cmd = "md5sum #{options[:output]}"
      session.exec(cmd)
      session.loop
    end
  end
end
puts "Wait the reporting server ..." if $Verbose
report_thr.join

if options[:okfile]!=nil
  oknode=[]
  nodes.each do |node|
    oknode << node if koNodes[node]==nil
  end
  if $Verbose
    oknode.each do |node|
      puts "[node Ok] #{node}"
    end
  end
  begin
    file=File.open(options[:okfile],"w")
    file.puts oknode.to_yaml
    file.close
  rescue =>e
    $stderr.puts "error during open file #{options[:okfile]} #{e.to_s}"
  end
end
if options[:kofile]!=nil
  if $Verbose
    koNodes.each do |node,error|
      puts "[node ko] #{node} - #{error}"
    end
  end
  begin
    file=File.open(options[:kofile],"w")
    file.puts koNodes.to_yaml
    file.close
  rescue =>e
    $stderr.puts "error during open file #{options[:kofile]} #{e.to_s}"
  end
end
if  koNodes.size ==0
  exit 0
else 
  if koNodes.size <= nodes.size
    exit 2
  else 
    exit 1
  end
end
=begin
# FOUNTAIN

#!/usr/bin/ruby

require 'socket'
require 'optparse'
require 'open3'

def reporting(node,error=nil)
      puts "report #{node} to #{$master}:#{$masterPort}" if $Verbose
      reportClient = TCPSocket.new($master, $masterPort)
      if error==nil
        reportClient.write(node+"\n")
      else
        reportClient.write("#{node} - #{error}\n")
      end
      reportClient.flush
      reportClient.close
end
def connectClient(nodes,ports,index)
  puts "try to connect index #{index}" if $Verbose
  client = nil
  attempts = 0
  while !client && nodes[index]
    begin
      client = TCPSocket.new(nodes[index], ports[index])
    rescue => e
      puts "failed to connect to #{nodes[index]} with ports #{ports[index]}" if $Verbose
      $stderr.puts e
      attempts += 1
      if attempts < 10
        puts "next attempt in 1s" if $Verbose
        sleep(1)
      else
        puts "reporting #{nodes[index]}..." if $Verbose
        reporting(nodes[index],e.to_s)
        index += 1
        attempts = 0
      end
    end
  end
  return client, index
end

def stack(list, e, max)
  if list.length == max
    list = list.drop(1)
  elsif list.length > max
    raise "stack has become too large!"
  end
  list << e
end

def redirect(input,output)
  Thread.new do
    until (line = input.gets).nil? do
      output.puts(line)
    end
  end
end
options = {}
OptionParser.new do |opts|
  opts.on("-i", "--input [FILE]", "input file") { |v| options[:input] = v }
  opts.on("-o", "--output [FILE]", "output file") { |v| options[:output] = v }
  opts.on("-O", "--outputcmd [CMD]", "output command") { |v| options[:outputcmd] = v }
  opts.on("-b", "--buffersize SIZE", "buffer size") { |v| options[:buffersize] = v.to_i }
  opts.on("-s", "--filesize SIZE", "file size") { |v| options[:filesize] = v.to_i }
  opts.on("-n", "--nodefile FILE", "node file") { |v| options[:nodefile] = v }
  opts.on("-v", "--[no-]verbose", "run verbosely") { |v| $Verbose = v }
end.parse!

MAX_CHUNKS = 63
nodes = []
ports = []
index = 0
sever = nil
client = nil
recoverPoint = 0
nbChunks = 0
lastChunks = []
bytes = 0
lastNode = false
fin = false
clientRecoverMode = false
serverRecoverMode = false


File.readlines(options[:nodefile]).map do |line|
  node, port = line.split(":")
  nodes << node.strip
  ports << port.to_i
end
$master=nodes[0]
$masterPort=ports[0]
index = nodes.index(Socket.gethostname)
if index==nil
  ips=Socket.ip_address_list
  index=nodes.find_index {|ip| ips.find_index{ |ip2| ip2.ip_address==ip}}
end
if index==nil
  reporting(Socket.gethostname,"I don't know who i am !")
  raise "I don't know who i am !"
end

# OPEN STREAMS
if !options[:input]
  begin
    if options[:outputcmd] != ""
      file,a,b = Open3.popen3(options[:outputcmd])
      redirect(a,$stdout)
            redirect(b,$stderr)
      raise "operation failed : " + options[:outputcmd] if !file
    else
      file = File.open(options[:output], "w")
      raise "failed to create " + options[:output] if !file
    end
  rescue => e
  reporting(nodes[index],"unable to open ouput #{e.to_s}")
  exit -1
  raise e
  end 

  begin
    server = TCPServer.new(ports[index])
    puts "TCPServer open on port #{ports[index]}" if $Verbose
  rescue => e 
    reporting(nodes[index],e.to_s.split('\n')[0])
    exit -1
    raise e
  end
  stream = server.accept
else
  stream = File.open(options[:input], "r")
end
client, nextIndex = connectClient(nodes, ports, index.next)
if client
  puts "connected to #{nodes[nextIndex]}" if $Verbose
else
  puts "last node of the chain" if $Verbose
  lastNode = true
end

# FILE TRANSMISSION

while !fin
  buffer = stream.read(options[:buffersize])
  if buffer
    begin
      client.write(buffer) if client
    rescue
      $stderr.puts "Failed to send data to #{nodes[nextIndex]} -- now switching to recover mode" if $Verbose
      reporting(nodes[nextIndex])
      clientRecoverMode = true
      while clientRecoverMode
        client.close
        client, nextIndex = connectClient(nodes, ports, nextIndex.next)
        if client
          puts "RECOVER CLIENT -- connected to #{nodes[nextIndex]}, waiting for its recover point" if $Verbose
          recoverPoint = client.recv(100).to_i
          puts "RECOVER CLIENT -- recover point received : #{recoverPoint} / #{nbChunks}" if $Verbose
          delta = nbChunks - recoverPoint
          raise "Not enough chunks saved for recover" if delta > MAX_CHUNKS
          begin
            lastChunks.last(delta).each do |chunk|
              client.write(chunk)
              puts "RECOVER CLIENT -- chunk resend ( #{chunk.length} bytes )" if $Verbose
            end
            puts "RECOVER CLIENT -- end" if $Verbose
            clientRecoverMode = false
          rescue => e
            puts "RECOVER CLIENT -- connexion lost with #{nodes[nextIndex]}" if $Verbose
      reporting(nodes[nextIndex],e.to_s)
          end
        else
          puts "RECOVER CLIENT -- new last node" if $Verbose
          lastNode = true
          clientRecoverMode = false
        end
      end
      retry
    end
    nbChunks += 1
    lastChunks = stack(lastChunks, buffer, MAX_CHUNKS)
    bytes += buffer.length
    file.write(buffer) if file
  elsif bytes == options[:filesize]
    fin = true
    puts "Transmission complete ( #{nbChunks} chunks )" if $Verbose
    if lastNode
      reporting("end")
    end
  else
    $stderr.puts "An error has occured ( #{bytes} / #{options[:filesize]} ) ( #{nbChunks} chunks ) -- now switching to Recover Mode" if $Verbose
    serverRecoverMode = true
    stream.close
    stream = server.accept
    puts "RECOVER SERVER -- connected" if $Verbose
    stream.send("#{nbChunks}", 0)
    puts "RECOVER SERVER -- recover points send to it : #{nbChunks}" if $Verbose
    serverRecoverMode = false
  end
end

# CLOSE STREAMS
stream.close
client.close if client
file.close if file
server.close if server

system("rm " + options[:nodefile] + " " + __FILE__)

# FOUNTAIN
=end
